<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Humpback Acoustic Embedding Platform</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #f5f7fa; color: #1a1a2e; }
header { background: #1a1a2e; color: #fff; padding: 1rem 2rem; display: flex; align-items: center; gap: 1rem; }
header h1 { font-size: 1.25rem; font-weight: 600; }
.tabs { display: flex; gap: 0; border-bottom: 2px solid #ddd; background: #fff; padding: 0 2rem; }
.tab-btn { padding: 0.75rem 1.5rem; border: none; background: none; cursor: pointer; font-size: 0.95rem; color: #666; border-bottom: 2px solid transparent; margin-bottom: -2px; }
.tab-btn.active { color: #1a1a2e; border-bottom-color: #3a86ff; font-weight: 600; }
.tab-content { display: none; padding: 1.5rem 2rem; max-width: 1100px; }
.tab-content.active { display: block; }
.card { background: #fff; border-radius: 8px; padding: 1.25rem; margin-bottom: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
.card h3 { margin-bottom: 0.75rem; font-size: 1rem; }
table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
th, td { text-align: left; padding: 0.5rem 0.75rem; border-bottom: 1px solid #eee; }
th { font-weight: 600; color: #555; font-size: 0.8rem; text-transform: uppercase; }
tr:hover { background: #f9f9ff; }
tr { cursor: pointer; }
button, .btn { padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; }
.btn-primary { background: #3a86ff; color: #fff; }
.btn-primary:hover { background: #2a76ef; }
.btn-danger { background: #e63946; color: #fff; }
.btn-danger:hover { background: #c5303c; }
.btn-sm { padding: 0.25rem 0.6rem; font-size: 0.8rem; }
input, select, textarea { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9rem; font-family: inherit; }
textarea { resize: vertical; }
label { font-size: 0.85rem; font-weight: 600; display: block; margin-bottom: 0.25rem; color: #444; }
.form-group { margin-bottom: 0.75rem; }
.form-row { display: flex; gap: 1rem; flex-wrap: wrap; }
.form-row .form-group { flex: 1; min-width: 180px; }
.badge { display: inline-block; padding: 0.15rem 0.5rem; border-radius: 10px; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; }
.badge-queued { background: #ffeaa7; color: #856404; }
.badge-running { background: #81ecec; color: #0c5460; }
.badge-complete { background: #a8e6cf; color: #155724; }
.badge-failed { background: #ff7675; color: #721c24; }
.badge-canceled { background: #dfe6e9; color: #636e72; }
.drop-zone { border: 2px dashed #ccc; border-radius: 8px; padding: 2rem; text-align: center; color: #888; transition: all 0.2s; }
.drop-zone.over { border-color: #3a86ff; background: #f0f6ff; color: #3a86ff; }
.drop-zone input[type="file"] { display: none; }
.detail-panel { background: #fff; border-radius: 8px; padding: 1.25rem; margin-bottom: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
.detail-panel .back-link { cursor: pointer; color: #3a86ff; font-size: 0.85rem; margin-bottom: 0.75rem; display: inline-block; }
.msg { padding: 0.75rem; border-radius: 4px; margin-bottom: 0.75rem; font-size: 0.9rem; }
.msg-success { background: #d4edda; color: #155724; }
.msg-error { background: #f8d7da; color: #721c24; }
.hidden { display: none !important; }
.empty { color: #999; font-style: italic; padding: 1rem 0; }
.checkbox-list { max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px; padding: 0.5rem; }
.checkbox-list label { font-weight: normal; display: flex; align-items: center; gap: 0.5rem; padding: 0.25rem 0; cursor: pointer; }
.upload-progress { margin-top: 0.75rem; }
.upload-progress .bar-track { background: #eee; border-radius: 4px; height: 6px; overflow: hidden; }
.upload-progress .bar-fill { background: #3a86ff; height: 100%; width: 0%; transition: width 0.3s; }
.upload-progress .bar-label { font-size: 0.8rem; color: #666; margin-top: 0.25rem; }
.tree-folder { margin-left: 0.5rem; }
.tree-folder-header { display: flex; align-items: center; gap: 0.4rem; padding: 0.3rem 0.25rem; cursor: pointer; font-weight: 600; font-size: 0.9rem; color: #333; user-select: none; border-radius: 4px; }
.tree-folder-header:hover { background: #f0f4ff; }
.tree-folder-header .arrow { display: inline-block; width: 1rem; text-align: center; font-size: 0.7rem; transition: transform 0.15s; color: #888; }
.tree-folder-header .arrow.open { transform: rotate(90deg); }
.tree-folder-children { margin-left: 1rem; border-left: 1px solid #e0e0e0; padding-left: 0.25rem; }
.tree-folder-children.collapsed { display: none; }
.tree-file-row { display: flex; align-items: center; gap: 0.75rem; padding: 0.3rem 0.5rem; font-size: 0.88rem; border-radius: 4px; cursor: pointer; }
.tree-file-row:hover { background: #f0f6ff; }
.tree-file-row .file-icon { color: #888; font-size: 0.8rem; }
.tree-file-row .file-name { flex: 1; }
.tree-file-row .file-meta { color: #888; font-size: 0.8rem; white-space: nowrap; }
.audio-bar { display:flex;align-items:center;gap:4px;background:#f0f2f5;border-radius:6px;padding:4px 8px;margin-top:4px;width:100%;flex-wrap:wrap; }
.audio-bar .play-btn { width:28px;height:28px;border:none;border-radius:50%;background:#3b82f6;color:#fff;font-size:0.85rem;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;padding:0;flex-shrink:0;transition:background 0.15s; }
.audio-bar .play-btn:hover { background:#2563eb; }
.audio-bar .row-chip { display:inline-flex;align-items:center;justify-content:center;min-width:28px;height:24px;padding:0 6px;border:1px solid #ccc;border-radius:4px;background:#fff;font-size:0.75rem;cursor:pointer;color:#333;transition:all 0.15s; }
.audio-bar .row-chip:hover { background:#e0edff;border-color:#5b9cf0; }
.audio-bar .row-chip-active { background:#3b82f6;color:#fff;border-color:#3b82f6; }
.audio-bar .vol-container { display:inline-flex;align-items:center;gap:2px;margin-left:auto;font-size:0.8rem;flex-shrink:0; }
.audio-bar .vol-slider { width:60px;height:4px;cursor:pointer;accent-color:#3b82f6; }
.audio-bar .dl-btn { color:#555;text-decoration:none;font-size:1rem;padding:0 4px;flex-shrink:0; }
.audio-bar .dl-btn:hover { color:#3b82f6; }
.audio-bar .hidden-audio { display:none; }
.audio-bar .time-indicator { display:flex;align-items:center;gap:4px;width:100%;margin-top:2px;font-size:0.7rem;color:#555; }
.audio-bar .time-label { white-space:nowrap;min-width:36px; }
.audio-bar .time-label-end { text-align:right; }
.audio-bar .time-track { flex:1;height:6px;background:#dde1e7;border-radius:3px;position:relative;overflow:hidden;min-width:60px; }
.audio-bar .time-region { position:absolute;top:0;height:100%;background:#93b8f7;border-radius:3px;transition:left 0.2s,width 0.2s; }
.audio-bar .time-playhead { position:absolute;top:-1px;width:2px;height:8px;background:#1d4ed8;border-radius:1px;transition:left 0.05s linear; }
.tree-root { margin-top: 0.5rem; }
.umap-plot-container { margin-top: 0.75rem; }
.btn-umap { background: #6c5ce7; color: #fff; margin-top: 0.5rem; }
.btn-umap:hover { background: #5a4bd1; }
.btn-export { background: #2a9d8f; color: #fff; margin-top: 0.5rem; }
.btn-export:hover { background: #238b7e; }
.umap-no-data { color: #888; font-style: italic; padding: 1rem 0; }
</style>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js" charset="utf-8"></script>
</head>
<body>

<header>
  <h1>Humpback Acoustic Embedding Platform</h1>
</header>

<div class="tabs">
  <button class="tab-btn active" data-tab="audio">Audio</button>
  <button class="tab-btn" data-tab="processing">Processing</button>
  <button class="tab-btn" data-tab="clustering">Clustering</button>
  <button class="tab-btn" data-tab="admin">Admin</button>
</div>

<!-- ==================== AUDIO TAB ==================== -->
<div id="audio" class="tab-content active">
  <div id="audio-list-view">
    <div class="card">
      <h3>Upload Audio</h3>
      <div class="drop-zone" id="drop-zone">
        <p>Drag &amp; drop audio files or a folder here, or <a href="#" id="browse-link">browse files</a> / <a href="#" id="browse-folder-link">browse folder</a></p>
        <input type="file" id="audio-file-input" accept=".wav,.mp3,.flac" multiple>
        <input type="file" id="audio-folder-input" accept=".wav,.mp3,.flac" webkitdirectory multiple>
      </div>
      <div id="upload-progress" class="upload-progress hidden">
        <div class="bar-track"><div class="bar-fill" id="upload-bar"></div></div>
        <div class="bar-label" id="upload-bar-label"></div>
      </div>
      <div id="upload-msg"></div>
    </div>
    <div class="card">
      <h3>Audio Files</h3>
      <div id="audio-tree-container" class="tree-root"></div>
      <p id="audio-empty" class="empty hidden">No audio files uploaded yet.</p>
    </div>
  </div>

  <div id="audio-detail-view" class="hidden">
    <div class="detail-panel">
      <span class="back-link" id="audio-back">&larr; Back to list</span>
      <h3 id="audio-detail-title"></h3>
      <table id="audio-detail-info"><tbody></tbody></table>
    </div>
    <div class="detail-panel">
      <h3>Processing History</h3>
      <table>
        <thead><tr><th>Job ID</th><th>Status</th><th>Model</th><th>Window</th><th>Created</th></tr></thead>
        <tbody id="audio-proc-history"></tbody>
      </table>
      <p id="audio-proc-empty" class="empty hidden">No processing jobs for this file.</p>
    </div>
    <div id="viz-panel" class="detail-panel hidden">
      <h3>Spectrogram &amp; Embedding Visualization</h3>
      <div class="form-row" style="align-items:center;margin-bottom:0.75rem;">
        <div class="form-group" style="flex:0 0 auto;min-width:220px;">
          <label for="viz-es-select">Embedding Set</label>
          <select id="viz-es-select" style="width:100%"></select>
        </div>
        <div style="display:flex;align-items:center;gap:0.5rem;margin-top:1.2rem;">
          <button class="btn btn-sm btn-primary" id="viz-prev-btn">&larr; Prev</button>
          <span id="viz-window-label" style="font-size:0.85rem;white-space:nowrap;">Window 0 of 0</span>
          <button class="btn btn-sm btn-primary" id="viz-next-btn">Next &rarr;</button>
        </div>
      </div>
      <div id="viz-audio-bar"></div>
      <div id="viz-spectrogram" style="height:300px;"></div>
      <div id="viz-embeddings" style="height:400px;margin-top:0.75rem;"></div>
      <p id="viz-empty" class="empty hidden">No completed embedding sets for this file.</p>
    </div>
  </div>
</div>

<!-- ==================== PROCESSING TAB ==================== -->
<div id="processing" class="tab-content">
  <div class="card">
    <h3>Queue Processing Job</h3>
    <div class="form-row">
      <div class="form-group">
        <label>Audio File</label>
        <select id="proc-audio-select"><option value="">-- select --</option></select>
      </div>
      <div class="form-group">
        <label>Model Version</label>
        <select id="proc-model"><option value="">-- loading --</option></select>
      </div>
      <div class="form-group">
        <label>Window Size (s)</label>
        <input type="number" id="proc-window" value="5" step="0.5" min="0.5">
      </div>
      <div class="form-group">
        <label>Sample Rate</label>
        <input type="number" id="proc-rate" value="32000" min="8000">
      </div>
    </div>
    <button class="btn btn-primary" id="queue-proc-btn">Queue Job</button>
    <button class="btn btn-primary" id="queue-all-proc-btn" style="margin-left:0.5rem">Queue All Unprocessed</button>
    <div id="proc-msg"></div>
    <div id="proc-batch-progress" class="upload-progress hidden">
      <div class="bar-track"><div class="bar-fill" id="proc-batch-bar"></div></div>
      <div class="bar-label" id="proc-batch-label"></div>
    </div>
  </div>
  <div class="card">
    <h3>Processing Jobs</h3>
    <div id="proc-tree-container" class="tree-root"></div>
    <p id="proc-empty" class="empty hidden">No processing jobs.</p>
  </div>
  <div class="card">
    <h3>Embedding Sets</h3>
    <div id="embed-tree-container" class="tree-root"></div>
    <p id="embed-empty" class="empty hidden">No embedding sets.</p>
  </div>
</div>

<!-- ==================== CLUSTERING TAB ==================== -->
<div id="clustering" class="tab-content">
  <div class="card">
    <h3>Queue Clustering Job</h3>
    <div class="form-group">
      <label>Select Embedding Sets</label>
      <button type="button" class="btn" id="cluster-toggle-all-btn" style="margin-bottom:0.5em;font-size:0.85em;padding:0.25em 0.75em;">Select All</button>
      <div class="checkbox-list" id="cluster-embed-list"></div>
      <p id="cluster-embed-empty" class="empty hidden">No embedding sets available.</p>
    </div>
    <h4 style="margin-top:0.75rem;margin-bottom:0.5rem;font-size:0.9rem">HDBSCAN Parameters</h4>
    <div class="form-row">
      <div class="form-group">
        <label>Min Cluster Size</label>
        <input type="number" id="cluster-min-size" value="5" min="2" step="1">
      </div>
      <div class="form-group">
        <label>Min Samples <span style="font-weight:normal;color:#888">(optional)</span></label>
        <input type="number" id="cluster-min-samples" value="" min="1" step="1" placeholder="default: min_cluster_size">
      </div>
    </div>
    <h4 style="margin-top:0.5rem;margin-bottom:0.5rem;font-size:0.9rem">UMAP Dimensionality Reduction</h4>
    <div class="form-row">
      <div class="form-group">
        <label><input type="checkbox" id="cluster-use-umap" checked style="margin-right:0.4rem">Enable UMAP</label>
      </div>
      <div class="form-group">
        <label>Components</label>
        <input type="number" id="cluster-umap-components" value="2" min="2" max="50" step="1">
      </div>
      <div class="form-group">
        <label>Neighbors</label>
        <input type="number" id="cluster-umap-neighbors" value="15" min="2" max="200" step="1">
      </div>
      <div class="form-group">
        <label>Min Distance</label>
        <input type="number" id="cluster-umap-min-dist" value="0.1" min="0" max="1" step="0.01">
      </div>
    </div>
    <button class="btn btn-primary" id="queue-cluster-btn">Queue Clustering Job</button>
    <div id="cluster-msg"></div>
  </div>
  <div class="card">
    <h3>Clustering Jobs</h3>
    <div id="cluster-jobs-container"></div>
    <p id="cluster-jobs-empty" class="empty hidden">No clustering jobs.</p>
  </div>
</div>

<!-- ==================== ADMIN TAB ==================== -->
<div id="admin" class="tab-content">
  <div class="card">
    <h3>Model Registry</h3>
    <table>
      <thead><tr><th>Name</th><th>Display Name</th><th>Path</th><th>Type</th><th>Input</th><th>Dims</th><th>Default</th><th></th></tr></thead>
      <tbody id="admin-models-body"></tbody>
    </table>
    <p id="admin-models-empty" class="empty hidden">No models registered.</p>
    <div style="margin-top:0.75rem">
      <button class="btn btn-primary" id="scan-models-btn">Scan for Models</button>
    </div>
    <div id="scan-results" class="hidden" style="margin-top:0.75rem">
      <h4 style="font-size:0.9rem;margin-bottom:0.5rem">Unregistered Model Files</h4>
      <div id="scan-results-list"></div>
    </div>
    <div id="admin-models-msg"></div>
  </div>
  <div class="card">
    <h3>Database Tables</h3>
    <table>
      <thead><tr><th>Table</th><th>Row Count</th></tr></thead>
      <tbody id="admin-table-body"></tbody>
    </table>
    <p id="admin-empty" class="empty hidden">No tables found.</p>
    <div style="margin-top:1rem">
      <button class="btn btn-danger" id="delete-all-btn">Delete All Records</button>
    </div>
    <div id="admin-msg"></div>
  </div>
</div>

<script>
// ---- Helpers ----
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => document.querySelectorAll(sel);
const api = async (path, opts = {}) => {
  const res = await fetch(path, opts);
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`${res.status}: ${text}`);
  }
  return res.json();
};
const shortId = (id) => id.slice(0, 8);
const fmtDate = (d) => new Date(d).toLocaleString();
const formatTime = (s) => { const m = Math.floor(s / 60); const sec = Math.floor(s % 60); return m + ':' + String(sec).padStart(2, '0'); };
const badgeHtml = (status) => `<span class="badge badge-${status}">${status}</span>`;
const jsonPretty = (obj) => obj ? JSON.stringify(obj, null, 2) : '{}';

function showMsg(elId, text, type = 'success') {
  const el = document.getElementById(elId);
  el.innerHTML = `<div class="msg msg-${type}">${text}</div>`;
  setTimeout(() => el.innerHTML = '', 4000);
}

// ---- Tab switching ----
$$('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    $$('.tab-btn').forEach(b => b.classList.remove('active'));
    $$('.tab-content').forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    $('#' + btn.dataset.tab).classList.add('active');
    if (btn.dataset.tab === 'audio') loadAudioList();
    if (btn.dataset.tab === 'processing') { loadAudioOptions(); loadModelOptions(); loadProcJobs(); loadEmbeddingSets(); }
    if (btn.dataset.tab === 'clustering') { loadClusterEmbedOptions(); loadAllClusterJobs(); }
    if (btn.dataset.tab === 'admin') { loadAdminTables(); loadAdminModels(); }
  });
});

// ---- Audio file cache (id -> {filename, folder_path}) ----
let audioFileMap = {};

/**
 * Build an expandable folder tree from a list of items.
 * @param {Array} items - data items to display
 * @param {Function} getPath - (item) => folder path string (e.g. "a/b/c")
 * @param {Function} renderLeaf - (item) => HTML string for the leaf row
 * @param {Object} expandState - persistent object tracking open/closed folders
 * @param {HTMLElement} container - DOM element to render into
 */
function buildFolderTree(items, getPath, renderLeaf, expandState, container) {
  // Build trie structure
  const root = { children: {}, items: [] };
  for (const item of items) {
    const path = getPath(item);
    if (!path) {
      root.items.push(item);
      continue;
    }
    const parts = path.split('/');
    let node = root;
    for (const part of parts) {
      if (!node.children[part]) node.children[part] = { children: {}, items: [] };
      node = node.children[part];
    }
    node.items.push(item);
  }

  function renderNode(node, pathSoFar) {
    let html = '';
    // Render subfolders sorted alphabetically
    const folderNames = Object.keys(node.children).sort();
    for (const name of folderNames) {
      const fullPath = pathSoFar ? pathSoFar + '/' + name : name;
      const isOpen = expandState[fullPath] !== false; // default open
      const child = node.children[name];
      const count = countItems(child);
      html += `<div class="tree-folder">
        <div class="tree-folder-header" data-path="${fullPath}">
          <span class="arrow ${isOpen ? 'open' : ''}">\u25B6</span>
          <span>\uD83D\uDCC1 ${name}</span>
          <span style="color:#999;font-weight:normal;font-size:0.8rem">(${count})</span>
        </div>
        <div class="tree-folder-children ${isOpen ? '' : 'collapsed'}">
          ${renderNode(child, fullPath)}
        </div>
      </div>`;
    }
    // Render leaf items
    for (const item of node.items) {
      html += renderLeaf(item);
    }
    return html;
  }

  function countItems(node) {
    let c = node.items.length;
    for (const child of Object.values(node.children)) c += countItems(child);
    return c;
  }

  container.innerHTML = renderNode(root, '');

  // Attach expand/collapse handlers
  container.querySelectorAll('.tree-folder-header').forEach(header => {
    header.addEventListener('click', () => {
      const path = header.dataset.path;
      const children = header.nextElementSibling;
      const arrow = header.querySelector('.arrow');
      const isOpen = !children.classList.contains('collapsed');
      if (isOpen) {
        children.classList.add('collapsed');
        arrow.classList.remove('open');
        expandState[path] = false;
      } else {
        children.classList.remove('collapsed');
        arrow.classList.add('open');
        expandState[path] = true;
      }
    });
  });
}

// ==================== AUDIO ====================
const audioTreeExpand = {};

async function loadAudioList() {
  try {
    const files = await api('/audio/');
    audioFileMap = {};
    files.forEach(f => { audioFileMap[f.id] = { filename: f.filename, folder_path: f.folder_path || '', duration: f.duration_seconds || 0 }; });
    const container = $('#audio-tree-container');
    if (files.length === 0) {
      container.innerHTML = '';
      $('#audio-empty').classList.remove('hidden');
      return;
    }
    $('#audio-empty').classList.add('hidden');

    buildFolderTree(
      files,
      f => f.folder_path || '',
      f => `<div class="tree-file-row" data-id="${f.id}">
        <span class="file-icon">\uD83C\uDFB5</span>
        <span class="file-name">${f.filename}</span>
        <span class="file-meta">${f.duration_seconds ? f.duration_seconds.toFixed(1) + 's' : '-'}</span>
        <span class="file-meta">${f.sample_rate_original ? f.sample_rate_original + ' Hz' : ''}</span>
        <span class="file-meta">${fmtDate(f.created_at)}</span>
      </div>`,
      audioTreeExpand,
      container,
    );

    container.querySelectorAll('.tree-file-row').forEach(row => {
      row.addEventListener('click', () => showAudioDetail(row.dataset.id));
    });
  } catch (e) { console.error(e); }
}

async function showAudioDetail(id) {
  try {
    const af = await api(`/audio/${id}`);
    $('#audio-list-view').classList.add('hidden');
    $('#audio-detail-view').classList.remove('hidden');
    $('#audio-detail-title').textContent = af.filename;
    $('#audio-detail-info tbody').innerHTML = `
      <tr><td><strong>ID</strong></td><td>${af.id}</td></tr>
      <tr><td><strong>SHA-256</strong></td><td style="word-break:break-all;font-size:0.8rem">${af.checksum_sha256}</td></tr>
      <tr><td><strong>Duration</strong></td><td>${af.duration_seconds ? af.duration_seconds.toFixed(1) + 's' : '-'}</td></tr>
      <tr><td><strong>Sample Rate</strong></td><td>${af.sample_rate_original || '-'}</td></tr>
      <tr><td><strong>Created</strong></td><td>${fmtDate(af.created_at)}</td></tr>`;
    $('#audio-detail-view').dataset.audioId = id;

    // Load processing history for this audio
    const jobs = await api('/processing/jobs');
    const related = jobs.filter(j => j.audio_file_id === id);
    const histTbody = $('#audio-proc-history');
    if (related.length === 0) {
      histTbody.innerHTML = '';
      $('#audio-proc-empty').classList.remove('hidden');
    } else {
      $('#audio-proc-empty').classList.add('hidden');
      histTbody.innerHTML = related.map(j => `
        <tr>
          <td>${shortId(j.id)}</td>
          <td>${badgeHtml(j.status)}</td>
          <td>${j.model_version}</td>
          <td>${j.window_size_seconds}s</td>
          <td>${fmtDate(j.created_at)}</td>
        </tr>`).join('');
    }

    // Load visualization panel
    loadVisualizationPanel(id);
  } catch (e) { console.error(e); }
}

// ---- Spectrogram & Embedding Visualization ----
let vizState = { audioId: null, windowIndex: 0, totalWindows: 0, embeddingData: null };

async function loadVisualizationPanel(audioId) {
  vizState.audioId = audioId;
  vizState.windowIndex = 0;
  vizState.totalWindows = 0;
  vizState.embeddingData = null;
  const panel = $('#viz-panel');
  const sel = $('#viz-es-select');
  const empty = $('#viz-empty');

  try {
    const allSets = await api('/processing/embedding-sets');
    const sets = allSets.filter(s => s.audio_file_id === audioId);
    if (sets.length === 0) {
      panel.classList.remove('hidden');
      empty.classList.remove('hidden');
      $('#viz-audio-bar').innerHTML = '';
      $('#viz-spectrogram').innerHTML = '';
      $('#viz-embeddings').innerHTML = '';
      sel.innerHTML = '';
      return;
    }
    empty.classList.add('hidden');
    panel.classList.remove('hidden');
    vizState._embeddingSets = sets;
    sel.innerHTML = sets.map(s =>
      `<option value="${s.id}">${shortId(s.id)} (${s.model_version}, ${s.vector_dim}d)</option>`
    ).join('');
    await onEmbeddingSetChange();
  } catch (e) { console.error('viz load error', e); }
}

async function onEmbeddingSetChange() {
  const esId = $('#viz-es-select').value;
  if (!esId) return;
  await loadEmbeddings(vizState.audioId, esId);
  await loadSpectrogram(vizState.audioId, 0);
  buildVizAudioBar(esId);
}

function buildVizAudioBar(esId) {
  const container = $('#viz-audio-bar');
  const aid = vizState.audioId;
  const totalWindows = vizState.totalWindows;
  if (!aid || totalWindows === 0) { container.innerHTML = ''; return; }

  // Look up embedding set info for window_size_seconds
  const sel = $('#viz-es-select');
  const allSetsInfo = vizState._embeddingSets || [];
  const esInfo = allSetsInfo.find(s => s.id === esId);
  const windowSize = esInfo ? esInfo.window_size_seconds : 5;
  const info = audioFileMap[aid];
  const totalDur = info ? info.duration : totalWindows * windowSize;
  const durLabel = formatTime(totalDur);

  // Build window chips
  let chipsHtml = '';
  const maxChips = 40;
  for (let i = 0; i < Math.min(totalWindows, maxChips); i++) {
    const start = i * windowSize;
    const active = i === vizState.windowIndex ? ' row-chip-active' : '';
    chipsHtml += `<button class="row-chip${active}" data-start="${start}" data-dur="${windowSize}" data-ri="${i}" title="Window ${i} (${start}s\u2013${start + windowSize}s)">${i}</button>`;
  }
  if (totalWindows > maxChips) chipsHtml += `<span class="file-meta"> ... (${totalWindows} total)</span>`;

  container.innerHTML = `<div class="audio-bar" id="viz-audio-bar-inner" data-audio-id="${aid}" data-window-size="${windowSize}" data-duration="${totalDur}">
    <button class="play-btn" title="Play">\u25B6</button>
    ${chipsHtml}
    <button class="row-chip full-chip" data-mode="full">Full</button>
    <span class="vol-container">\uD83D\uDD08<input type="range" class="vol-slider" min="0" max="1" step="0.1" value="1"></span>
    <a class="dl-btn" href="/audio/${aid}/download" title="Download">\u22EF</a>
    <audio preload="metadata" class="hidden-audio"></audio>
    <div class="time-indicator">
      <span class="time-label time-start">0:00</span>
      <div class="time-track">
        <div class="time-region" style="left:0%;width:100%"></div>
        <div class="time-playhead" style="left:0%"></div>
      </div>
      <span class="time-label time-label-end time-end">${durLabel}</span>
    </div>
  </div>`;

  // Wire up controls
  const bar = container.querySelector('.audio-bar');
  const audio = bar.querySelector('.hidden-audio');
  const playBtn = bar.querySelector('.play-btn');
  const volSlider = bar.querySelector('.vol-slider');
  const timeRegion = bar.querySelector('.time-region');
  const timePlayhead = bar.querySelector('.time-playhead');
  const timeStart = bar.querySelector('.time-start');
  const timeEnd = bar.querySelector('.time-end');
  let selStart = 0, selEnd = totalDur;

  function updateTimeBar(start, end) {
    selStart = start; selEnd = end;
    timeStart.textContent = formatTime(start);
    timeEnd.textContent = formatTime(end);
    if (totalDur > 0) {
      timeRegion.style.left = (start / totalDur * 100) + '%';
      timeRegion.style.width = ((end - start) / totalDur * 100) + '%';
    } else {
      timeRegion.style.left = '0%';
      timeRegion.style.width = '100%';
    }
    timePlayhead.style.left = (totalDur > 0 ? (start / totalDur * 100) : 0) + '%';
  }

  // Default to current window
  const initStart = vizState.windowIndex * windowSize;
  audio.src = `/audio/${aid}/window?start_seconds=${initStart}&duration_seconds=${windowSize}`;
  updateTimeBar(initStart, initStart + windowSize);

  audio.addEventListener('timeupdate', () => {
    if (totalDur > 0) {
      const absTime = selStart + audio.currentTime;
      timePlayhead.style.left = (absTime / totalDur * 100) + '%';
    }
  });

  playBtn.addEventListener('click', () => {
    if (audio.paused) { audio.play(); } else { audio.pause(); }
  });
  audio.addEventListener('play', () => { playBtn.textContent = '\u23F8'; });
  audio.addEventListener('pause', () => { playBtn.textContent = '\u25B6'; });
  audio.addEventListener('ended', () => { playBtn.textContent = '\u25B6'; });

  bar.querySelectorAll('.row-chip:not(.full-chip)').forEach(chip => {
    chip.addEventListener('click', () => {
      bar.querySelectorAll('.row-chip').forEach(c => c.classList.remove('row-chip-active'));
      chip.classList.add('row-chip-active');
      const s = parseFloat(chip.dataset.start);
      const d = parseFloat(chip.dataset.dur);
      const ri = parseInt(chip.dataset.ri);
      updateTimeBar(s, s + d);
      audio.src = `/audio/${aid}/window?start_seconds=${s}&duration_seconds=${d}`;
      audio.play();
      // Sync spectrogram/embedding views
      loadSpectrogram(aid, ri);
    });
  });

  const fullChip = bar.querySelector('.full-chip');
  fullChip.addEventListener('click', () => {
    bar.querySelectorAll('.row-chip').forEach(c => c.classList.remove('row-chip-active'));
    fullChip.classList.add('row-chip-active');
    updateTimeBar(0, totalDur);
    audio.src = `/audio/${aid}/download`;
    audio.play();
  });

  volSlider.addEventListener('input', () => { audio.volume = volSlider.value; });
}

function updateVizAudioBarActiveChip(windowIndex) {
  const bar = $('#viz-audio-bar-inner');
  if (!bar) return;
  bar.querySelectorAll('.row-chip').forEach(c => c.classList.remove('row-chip-active'));
  const chip = bar.querySelector(`.row-chip[data-ri="${windowIndex}"]`);
  if (chip) chip.classList.add('row-chip-active');
  // Update audio source to the new window
  const aid = bar.dataset.audioId;
  const ws = parseFloat(bar.dataset.windowSize) || 5;
  const totalDur = parseFloat(bar.dataset.duration) || 0;
  const audio = bar.querySelector('.hidden-audio');
  const start = windowIndex * ws;
  audio.src = `/audio/${aid}/window?start_seconds=${start}&duration_seconds=${ws}`;
  // Update time bar
  const timeStart = bar.querySelector('.time-start');
  const timeEnd = bar.querySelector('.time-end');
  const timeRegion = bar.querySelector('.time-region');
  const timePlayhead = bar.querySelector('.time-playhead');
  timeStart.textContent = formatTime(start);
  timeEnd.textContent = formatTime(start + ws);
  if (totalDur > 0) {
    timeRegion.style.left = (start / totalDur * 100) + '%';
    timeRegion.style.width = (ws / totalDur * 100) + '%';
    timePlayhead.style.left = (start / totalDur * 100) + '%';
  }
}

async function loadSpectrogram(audioId, windowIndex) {
  try {
    const resp = await api(`/audio/${audioId}/spectrogram?window_index=${windowIndex}`);
    vizState.windowIndex = windowIndex;
    vizState.totalWindows = resp.total_windows;
    $('#viz-window-label').textContent = `Window ${windowIndex} of ${resp.total_windows}`;
    Plotly.react('viz-spectrogram', [{
      z: resp.data,
      type: 'heatmap',
      colorscale: 'Viridis',
      zmin: resp.min_db,
      zmax: resp.max_db,
      colorbar: { title: 'dB', thickness: 12 },
    }], {
      margin: { t: 30, b: 40, l: 50, r: 20 },
      xaxis: { title: 'Time Frame' },
      yaxis: { title: 'Mel Bin', autorange: 'reversed' },
      title: { text: `Spectrogram â€” Window ${windowIndex}`, font: { size: 13 } },
    }, { responsive: true });
    highlightEmbeddingRow(windowIndex);
  } catch (e) { console.error('spectrogram error', e); }
}

async function loadEmbeddings(audioId, embeddingSetId) {
  try {
    const resp = await api(`/audio/${audioId}/embeddings?embedding_set_id=${embeddingSetId}`);
    vizState.embeddingData = resp;
    const n = resp.num_windows;
    const labels = resp.row_indices.map(i => `W${i}`);
    Plotly.react('viz-embeddings', [{
      z: resp.similarity_matrix,
      x: labels,
      y: labels,
      type: 'heatmap',
      colorscale: 'RdBu',
      zmin: -1,
      zmax: 1,
      colorbar: { title: 'Cosine Sim', thickness: 12 },
    }], {
      margin: { t: 30, b: 50, l: 50, r: 20 },
      xaxis: { title: 'Window', side: 'bottom' },
      yaxis: { title: 'Window', autorange: 'reversed' },
      title: { text: 'Pairwise Cosine Similarity', font: { size: 13 } },
    }, { responsive: true });
    // Click on similarity matrix navigates spectrogram to that window
    const vizEl = document.getElementById('viz-embeddings');
    vizEl.removeListener && vizEl.removeListener('plotly_click', vizEl._vizClickHandler);
    vizEl._vizClickHandler = function(data) {
      if (data.points && data.points.length > 0) {
        const idx = data.points[0].pointIndex;
        const row = Array.isArray(idx) ? idx[0] : data.points[0].y;
        const winIdx = typeof row === 'number' ? row : resp.row_indices.indexOf(parseInt(String(row).replace('W', '')));
        if (winIdx >= 0 && winIdx < vizState.totalWindows) {
          loadSpectrogram(vizState.audioId, winIdx);
          updateVizAudioBarActiveChip(winIdx);
        }
      }
    };
    vizEl.on('plotly_click', vizEl._vizClickHandler);
    highlightEmbeddingRow(vizState.windowIndex);
  } catch (e) { console.error('embeddings error', e); }
}

function highlightEmbeddingRow(windowIndex) {
  const el = document.getElementById('viz-embeddings');
  if (!el || !vizState.embeddingData) return;
  const n = vizState.embeddingData.num_windows;
  Plotly.relayout('viz-embeddings', {
    shapes: [
      { type: 'line', x0: -0.5, x1: n - 0.5, y0: windowIndex, y1: windowIndex,
        line: { color: '#ff6b6b', width: 1.5, dash: 'dot' } },
      { type: 'line', x0: windowIndex, x1: windowIndex, y0: -0.5, y1: n - 0.5,
        line: { color: '#ff6b6b', width: 1.5, dash: 'dot' } },
    ],
  });
}

$('#viz-prev-btn').addEventListener('click', () => {
  if (vizState.windowIndex > 0) {
    const newIdx = vizState.windowIndex - 1;
    loadSpectrogram(vizState.audioId, newIdx);
    updateVizAudioBarActiveChip(newIdx);
  }
});
$('#viz-next-btn').addEventListener('click', () => {
  if (vizState.windowIndex < vizState.totalWindows - 1) {
    const newIdx = vizState.windowIndex + 1;
    loadSpectrogram(vizState.audioId, newIdx);
    updateVizAudioBarActiveChip(newIdx);
  }
});
$('#viz-es-select').addEventListener('change', () => onEmbeddingSetChange());

$('#audio-back').addEventListener('click', () => {
  $('#audio-detail-view').classList.add('hidden');
  $('#audio-list-view').classList.remove('hidden');
  loadAudioList();
});

// Upload
const dropZone = $('#drop-zone');
const fileInput = $('#audio-file-input');
const folderInput = $('#audio-folder-input');
const AUDIO_EXTENSIONS = ['.wav', '.mp3', '.flac'];

function isAudioFile(file) {
  const name = file.name.toLowerCase();
  return AUDIO_EXTENSIONS.some(ext => name.endsWith(ext));
}

$('#browse-link').addEventListener('click', (e) => { e.preventDefault(); fileInput.click(); });
$('#browse-folder-link').addEventListener('click', (e) => { e.preventDefault(); folderInput.click(); });
dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('over'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('over'));

dropZone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dropZone.classList.remove('over');
  const items = e.dataTransfer.items;
  let files = [];
  if (items) {
    // Try to read directories via webkitGetAsEntry
    const entries = [];
    for (const item of items) {
      const entry = item.webkitGetAsEntry && item.webkitGetAsEntry();
      if (entry) entries.push(entry);
    }
    if (entries.some(en => en.isDirectory)) {
      files = await readEntriesRecursive(entries);
    } else {
      files = [...e.dataTransfer.files];
    }
  } else {
    files = [...e.dataTransfer.files];
  }
  const audioFiles = files.filter(isAudioFile);
  if (audioFiles.length > 0) uploadFiles(audioFiles);
});

function readEntriesRecursive(entries) {
  return new Promise((resolve) => {
    const files = [];
    let pending = 0;

    function readAllEntries(reader) {
      // Chromium returns at most 100 entries per readEntries call
      return new Promise((res) => {
        const all = [];
        function readBatch() {
          reader.readEntries(batch => {
            if (batch.length === 0) { res(all); return; }
            all.push(...batch);
            readBatch();
          });
        }
        readBatch();
      });
    }

    function readEntry(entry, parentPath) {
      if (entry.isFile) {
        pending++;
        entry.file(f => {
          // Attach the folder path so uploadFiles can use it
          f._folderPath = parentPath;
          files.push(f);
          if (--pending === 0) resolve(files);
        });
      } else if (entry.isDirectory) {
        pending++;
        const dirPath = parentPath ? parentPath + '/' + entry.name : entry.name;
        const reader = entry.createReader();
        readAllEntries(reader).then(subEntries => {
          for (const sub of subEntries) readEntry(sub, dirPath);
          if (--pending === 0) resolve(files);
        });
      }
    }
    for (const entry of entries) readEntry(entry, '');
    if (pending === 0) resolve(files);
  });
}

fileInput.addEventListener('change', () => {
  const files = [...fileInput.files].filter(isAudioFile);
  // No folder path for direct file selection
  if (files.length > 0) uploadFiles(files);
  fileInput.value = '';
});
folderInput.addEventListener('change', () => {
  const files = [...folderInput.files].filter(isAudioFile);
  // Capture folder path from webkitRelativePath
  for (const f of files) {
    const rel = f.webkitRelativePath || '';
    const parts = rel.split('/');
    if (parts.length > 1) {
      f._folderPath = parts.slice(0, -1).join('/');
    }
  }
  if (files.length > 0) uploadFiles(files);
  folderInput.value = '';
});

async function uploadFiles(files) {
  const total = files.length;
  if (total === 0) return;
  const progressEl = $('#upload-progress');
  const bar = $('#upload-bar');
  const label = $('#upload-bar-label');
  progressEl.classList.remove('hidden');
  let done = 0, failed = 0;
  for (const file of files) {
    try {
      const form = new FormData();
      form.append('file', file);
      const folderPath = file._folderPath || '';
      if (folderPath) form.append('folder_path', folderPath);
      await api('/audio/upload', { method: 'POST', body: form });
    } catch (e) {
      failed++;
    }
    done++;
    bar.style.width = Math.round((done / total) * 100) + '%';
    label.textContent = `${done} / ${total}${failed ? ` (${failed} failed)` : ''}`;
  }
  const msg = failed
    ? `Uploaded ${done - failed} of ${total} files (${failed} failed)`
    : `Uploaded ${total} file${total > 1 ? 's' : ''}`;
  showMsg('upload-msg', msg, failed ? 'error' : 'success');
  setTimeout(() => progressEl.classList.add('hidden'), 2000);
  loadAudioList();
}

// ==================== PROCESSING ====================
function audioDisplayName(id) {
  const info = audioFileMap[id];
  if (!info) return shortId(id);
  return info.folder_path ? info.folder_path + '/' + info.filename : info.filename;
}

async function loadAudioOptions() {
  try {
    const files = await api('/audio/');
    audioFileMap = {};
    files.forEach(f => { audioFileMap[f.id] = { filename: f.filename, folder_path: f.folder_path || '', duration: f.duration_seconds || 0 }; });
    const sorted = [...files].sort((a, b) => {
      const pa = (a.folder_path || '') + '/' + a.filename;
      const pb = (b.folder_path || '') + '/' + b.filename;
      return pa.localeCompare(pb);
    });
    const sel = $('#proc-audio-select');
    sel.innerHTML = '<option value="">-- select --</option>' +
      sorted.map(f => {
        const display = f.folder_path ? f.folder_path + '/' + f.filename : f.filename;
        return `<option value="${f.id}">${display}</option>`;
      }).join('');
  } catch (e) { console.error(e); }
}

async function loadModelOptions() {
  try {
    const models = await api('/admin/models');
    const sel = $('#proc-model');
    sel.innerHTML = models.map(m =>
      `<option value="${m.name}"${m.is_default ? ' selected' : ''}>${m.display_name} (${m.vector_dim}d)</option>`
    ).join('');
    if (models.length === 0) sel.innerHTML = '<option value="">-- no models registered --</option>';
  } catch (e) { console.error(e); }
}

const procTreeExpand = {};
const embedTreeExpand = {};

async function loadProcJobs() {
  try {
    const jobs = await api('/processing/jobs');
    const container = $('#proc-tree-container');
    if (jobs.length === 0) {
      container.innerHTML = '';
      $('#proc-empty').classList.remove('hidden');
      return;
    }
    $('#proc-empty').classList.add('hidden');

    buildFolderTree(
      jobs,
      j => {
        const info = audioFileMap[j.audio_file_id];
        return info ? info.folder_path : '';
      },
      j => {
        const audioName = audioDisplayName(j.audio_file_id);
        const cancelBtn = (j.status === 'queued' || j.status === 'running')
          ? `<button class="btn btn-danger btn-sm cancel-proc" data-id="${j.id}" style="margin-left:0.5rem">Cancel</button>` : '';
        return `<div class="tree-file-row" style="cursor:default">
          <span class="file-meta">${shortId(j.id)}</span>
          <span class="file-name">${audioFileMap[j.audio_file_id]?.filename || shortId(j.audio_file_id)}</span>
          <span>${badgeHtml(j.status)}</span>
          <span class="file-meta">${j.model_version}</span>
          <span class="file-meta">${j.window_size_seconds}s</span>
          <span class="file-meta">${fmtDate(j.created_at)}</span>
          ${cancelBtn}
        </div>`;
      },
      procTreeExpand,
      container,
    );

    container.querySelectorAll('.cancel-proc').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        try {
          await api(`/processing/jobs/${btn.dataset.id}/cancel`, { method: 'POST' });
          loadProcJobs();
        } catch (err) { console.error(err); }
      });
    });
  } catch (e) { console.error(e); }
}

async function loadEmbeddingSets() {
  try {
    const sets = await api('/processing/embedding-sets');
    const container = $('#embed-tree-container');
    if (sets.length === 0) {
      container.innerHTML = '';
      $('#embed-empty').classList.remove('hidden');
      return;
    }
    $('#embed-empty').classList.add('hidden');

    buildFolderTree(
      sets,
      s => {
        const info = audioFileMap[s.audio_file_id];
        return info ? info.folder_path : '';
      },
      s => `<div class="tree-file-row" style="cursor:default">
        <span class="file-meta">${shortId(s.id)}</span>
        <span class="file-name">${audioFileMap[s.audio_file_id]?.filename || shortId(s.audio_file_id)}</span>
        <span class="file-meta">${s.model_version}</span>
        <span class="file-meta">${s.vector_dim}d</span>
        <span class="file-meta">${fmtDate(s.created_at)}</span>
      </div>`,
      embedTreeExpand,
      container,
    );
  } catch (e) { console.error(e); }
}

$('#queue-proc-btn').addEventListener('click', async () => {
  const audioId = $('#proc-audio-select').value;
  if (!audioId) { showMsg('proc-msg', 'Select an audio file', 'error'); return; }
  try {
    const body = {
      audio_file_id: audioId,
      model_version: $('#proc-model').value,
      window_size_seconds: parseFloat($('#proc-window').value),
      target_sample_rate: parseInt($('#proc-rate').value),
    };
    const result = await api('/processing/jobs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    showMsg('proc-msg', result.skipped ? 'Job skipped (embeddings already exist)' : `Job queued: ${shortId(result.id)}`);
    loadProcJobs();
  } catch (e) {
    showMsg('proc-msg', `Failed: ${e.message}`, 'error');
  }
});

$('#queue-all-proc-btn').addEventListener('click', async () => {
  try {
    const files = await api('/audio/');
    const jobs = await api('/processing/jobs');
    const model = $('#proc-model').value;
    const window = parseFloat($('#proc-window').value);
    const rate = parseInt($('#proc-rate').value);

    // Find audio files that don't already have a non-failed job with these settings
    const existingAudioIds = new Set(
      jobs.filter(j => j.model_version === model
        && j.window_size_seconds === window
        && j.target_sample_rate === rate
        && j.status !== 'failed'
      ).map(j => j.audio_file_id)
    );
    const toQueue = files.filter(f => !existingAudioIds.has(f.id));

    if (toQueue.length === 0) {
      showMsg('proc-msg', 'All audio files already have jobs queued or completed');
      return;
    }

    const progressEl = $('#proc-batch-progress');
    const bar = $('#proc-batch-bar');
    const label = $('#proc-batch-label');
    progressEl.classList.remove('hidden');
    let done = 0, skipped = 0, failed = 0;

    for (const file of toQueue) {
      try {
        const result = await api('/processing/jobs', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            audio_file_id: file.id,
            model_version: model,
            window_size_seconds: window,
            target_sample_rate: rate,
          }),
        });
        if (result.skipped) skipped++;
      } catch (e) {
        failed++;
      }
      done++;
      bar.style.width = Math.round((done / toQueue.length) * 100) + '%';
      label.textContent = `Queued ${done} / ${toQueue.length}${skipped ? ` (${skipped} skipped)` : ''}${failed ? ` (${failed} failed)` : ''}`;
    }

    const queued = done - skipped - failed;
    showMsg('proc-msg', `Queued ${queued} jobs, ${skipped} skipped, ${failed} failed`);
    setTimeout(() => progressEl.classList.add('hidden'), 3000);
    loadProcJobs();
  } catch (e) {
    showMsg('proc-msg', `Failed: ${e.message}`, 'error');
  }
});

// ==================== CLUSTERING ====================
// Store embedding sets data for client-side dim validation
let clusterEmbedSetsData = [];

async function loadClusterEmbedOptions() {
  try {
    const sets = await api('/processing/embedding-sets');
    clusterEmbedSetsData = sets;
    const container = $('#cluster-embed-list');
    if (sets.length === 0) {
      container.innerHTML = '';
      $('#cluster-embed-empty').classList.remove('hidden');
      return;
    }
    $('#cluster-embed-empty').classList.add('hidden');

    // Group by model_version
    const groups = {};
    for (const s of sets) {
      const key = s.model_version;
      if (!groups[key]) groups[key] = { vector_dim: s.vector_dim, sets: [] };
      groups[key].sets.push(s);
    }

    let html = '';
    for (const [model, group] of Object.entries(groups)) {
      html += `<div style="margin-bottom:0.75rem">
        <div style="font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;display:flex;align-items:center;gap:0.5rem">
          ${model} (${group.vector_dim}d)
          <button type="button" class="btn btn-sm cluster-group-select-all" data-model="${model}" style="font-size:0.75rem;padding:0.15rem 0.5rem">Select All</button>
        </div>`;
      // Sort by folder_path/filename
      const sorted = [...group.sets].sort((a, b) => {
        const pa = audioDisplayName(a.audio_file_id);
        const pb = audioDisplayName(b.audio_file_id);
        return pa.localeCompare(pb);
      });
      for (const s of sorted) {
        html += `<label><input type="checkbox" value="${s.id}" data-dim="${s.vector_dim}" data-model="${model}">
          ${audioDisplayName(s.audio_file_id)}
        </label>`;
      }
      html += `</div>`;
    }
    container.innerHTML = html;

    // Per-group "Select All" buttons
    container.querySelectorAll('.cluster-group-select-all').forEach(btn => {
      btn.addEventListener('click', () => {
        const model = btn.dataset.model;
        const boxes = [...container.querySelectorAll(`input[data-model="${model}"]`)];
        const allChecked = boxes.every(cb => cb.checked);
        boxes.forEach(cb => cb.checked = !allChecked);
        btn.textContent = allChecked ? 'Select All' : 'Unselect All';
      });
    });
  } catch (e) { console.error(e); }
}

$('#cluster-toggle-all-btn').addEventListener('click', () => {
  const boxes = [...$('#cluster-embed-list').querySelectorAll('input[type="checkbox"]')];
  if (boxes.length === 0) return;
  const allChecked = boxes.every(cb => cb.checked);
  boxes.forEach(cb => cb.checked = !allChecked);
  $('#cluster-toggle-all-btn').textContent = allChecked ? 'Select All' : 'Unselect All';
});

// Track expanded cluster labels so they survive polling redraws
const expandedClusters = new Map(); // cluster_id -> assignments HTML
const clusterAssignTreeExpand = {}; // persist expand state for assignment trees

async function loadClusterJobs() {
  try {
    const container = $('#cluster-jobs-container');
    if (clusterJobIds.length === 0) {
      container.innerHTML = '';
      $('#cluster-jobs-empty').classList.remove('hidden');
      return;
    }
    $('#cluster-jobs-empty').classList.add('hidden');

    // Pre-fetch embedding sets for audio name resolution
    let embeddingSets = [];
    try { embeddingSets = await api('/processing/embedding-sets'); } catch (_) {}
    const esMap = {};
    embeddingSets.forEach(s => { esMap[s.id] = s; });

    let html = '';
    let hasPending = false;
    for (const jid of clusterJobIds) {
      try {
        const job = await api(`/clustering/jobs/${jid}`);
        if (job.status === 'queued' || job.status === 'running') hasPending = true;
        let clustersHtml = '';
        if (job.status === 'complete') {
          try {
            const clusters = await api(`/clustering/jobs/${jid}/clusters`);
            if (clusters.length > 0) {
              clustersHtml = `<table><thead><tr><th>Label</th><th>Size</th><th>Summary</th></tr></thead><tbody>` +
                clusters.map(c => {
                  const expanded = expandedClusters.has(c.id);
                  let rows = `<tr class="cluster-row" data-id="${c.id}" style="cursor:pointer">
                    <td>${c.cluster_label}</td><td>${c.size}</td>
                    <td style="font-size:0.8rem">${c.metadata_summary ? JSON.stringify(c.metadata_summary) : '-'}</td>
                  </tr>`;
                  if (expanded) {
                    rows += `<tr class="assignment-row" data-cluster-id="${c.id}">
                      <td colspan="3">${expandedClusters.get(c.id)}</td>
                    </tr>`;
                  }
                  return rows;
                }).join('') + `</tbody></table>`;
            }
          } catch (_) {}
        }
        const paramsSummary = job.parameters ? `<div style="font-size:0.8rem;color:#666;margin-top:0.25rem">${Object.entries(job.parameters).map(([k,v]) => `${k}=${v}`).join(', ')}</div>` : '';
        const umapBtn = job.status === 'complete' ? `<button class="btn btn-umap" onclick="toggleUmapPlot('${jid}', event)">Show UMAP Plot</button>` : '';
        const evalBtn = job.status === 'complete' ? `<button class="btn" style="margin-left:0.5rem" onclick="toggleEvaluation('${jid}', event)">Show Evaluation</button>` : '';
        const exportBtn = job.status === 'complete' ? `<button class="btn btn-export" style="margin-left:0.5rem" onclick="exportClusterReport('${jid}')">Export Report</button>` : '';
        html += `<div class="card" style="margin-top:0.5rem">
          <strong>Job ${shortId(jid)}</strong> ${badgeHtml(job.status)}
          ${paramsSummary}
          ${job.error_message ? `<div class="msg msg-error" style="margin-top:0.5rem">${job.error_message}</div>` : ''}
          ${clustersHtml}
          <div style="display:flex;gap:0.25rem;margin-top:0.5rem">${umapBtn}${evalBtn}${exportBtn}</div>
          <div id="umap-plot-${jid}" class="umap-plot-container" style="display:none;height:500px"></div>
          <div id="eval-panel-${jid}" style="display:none;margin-top:0.75rem"></div>
        </div>`;
      } catch (_) {}
    }
    clusterJobsHavePending = hasPending;
    container.innerHTML = html;
    // Create audio elements programmatically (innerHTML can break media elements)
    container.querySelectorAll('.audio-placeholder').forEach(span => {
      const aid = span.dataset.audioId;
      const audio = document.createElement('audio');
      audio.controls = true;
      audio.preload = 'metadata';
      audio.style.cssText = 'height:32px;max-width:260px';
      audio.src = `/audio/${aid}/download`;
      span.replaceWith(audio);
    });

    // Attach click handlers for cluster rows to toggle assignment details
    container.querySelectorAll('.cluster-row').forEach(row => {
      row.addEventListener('click', async () => {
        const cid = row.dataset.id;
        // Toggle off if already expanded
        if (expandedClusters.has(cid)) {
          expandedClusters.delete(cid);
          const next = row.nextElementSibling;
          if (next && next.classList.contains('assignment-row')) next.remove();
          return;
        }
        try {
          const assignments = await api(`/clustering/clusters/${cid}/assignments`);
          // Group assignments by embedding_set_id
          const byEs = {};
          for (const a of assignments) {
            if (!byEs[a.embedding_set_id]) byEs[a.embedding_set_id] = [];
            byEs[a.embedding_set_id].push(a.embedding_row_index);
          }

          // Build items with folder info for tree display
          const assignItems = [];
          for (const [esId, rowIndices] of Object.entries(byEs)) {
            const es = esMap[esId];
            const audioFileId = es ? es.audio_file_id : null;
            const info = audioFileId ? audioFileMap[audioFileId] : null;
            assignItems.push({
              esId,
              audioFileId,
              filename: info ? info.filename : (audioFileId ? shortId(audioFileId) : '-'),
              folder_path: info ? info.folder_path : '',
              rowIndices,
              windowSize: es ? es.window_size_seconds : 5,
              duration: info ? info.duration : 0,
            });
          }

          // Build tree HTML
          const treeContainer = document.createElement('div');
          treeContainer.style.cssText = 'font-size:0.85rem;padding:0.5rem';
          treeContainer.innerHTML = `<strong>Assignments (${assignments.length}):</strong>`;
          const treeDiv = document.createElement('div');
          treeDiv.className = 'tree-root';
          treeContainer.appendChild(treeDiv);

          buildFolderTree(
            assignItems,
            item => item.folder_path,
            item => {
              const windowSize = item.windowSize || 5;
              const aid = item.audioFileId;
              const chips = item.rowIndices.map(ri => {
                const start = ri * windowSize;
                return `<button class="row-chip" data-start="${start}" data-dur="${windowSize}" data-ri="${ri}" title="Window ${ri} (${start}s\u2013${start + windowSize}s)">${ri}</button>`;
              });
              const chipsHtml = item.rowIndices.length > 40
                ? chips.slice(0, 40).join('') + `<span class="file-meta"> ... (${item.rowIndices.length} total)</span>`
                : chips.join('');
              const dur = item.duration || 0;
              const durLabel = formatTime(dur);
              const singleWindow = item.rowIndices.length === 1;
              const barHtml = aid
                ? `<div class="audio-bar" data-audio-id="${aid}" data-window-size="${windowSize}" data-duration="${dur}">
                    <button class="play-btn" title="Play">\u25B6</button>
                    ${chipsHtml}
                    <button class="row-chip${singleWindow ? '' : ' row-chip-active'} full-chip" data-mode="full">Full</button>
                    <span class="vol-container">\uD83D\uDD08<input type="range" class="vol-slider" min="0" max="1" step="0.1" value="1"></span>
                    <a class="dl-btn" href="/audio/${aid}/download" title="Download">\u22EF</a>
                    <audio preload="metadata" class="hidden-audio"></audio>
                    <div class="time-indicator">
                      <span class="time-label time-start">0:00</span>
                      <div class="time-track">
                        <div class="time-region" style="left:0%;width:100%"></div>
                        <div class="time-playhead" style="left:0%"></div>
                      </div>
                      <span class="time-label time-label-end time-end">${durLabel}</span>
                    </div>
                  </div>`
                : '';
              return `<div class="tree-file-row" style="cursor:default">
                <span class="file-icon">\uD83C\uDFB5</span>
                <span class="file-name">${item.filename}</span>
              </div>${barHtml}`;
            },
            clusterAssignTreeExpand,
            treeDiv,
          );

          // Wire up audio bar controls
          treeContainer.querySelectorAll('.audio-bar').forEach(bar => {
            const aid = bar.dataset.audioId;
            const audio = bar.querySelector('.hidden-audio');
            const playBtn = bar.querySelector('.play-btn');
            const volSlider = bar.querySelector('.vol-slider');
            const totalDur = parseFloat(bar.dataset.duration) || 0;
            const timeRegion = bar.querySelector('.time-region');
            const timePlayhead = bar.querySelector('.time-playhead');
            const timeStart = bar.querySelector('.time-start');
            const timeEnd = bar.querySelector('.time-end');
            let selStart = 0, selEnd = totalDur; // current selection range in seconds

            function updateTimeBar(start, end) {
              selStart = start; selEnd = end;
              timeStart.textContent = formatTime(start);
              timeEnd.textContent = formatTime(end);
              if (totalDur > 0) {
                timeRegion.style.left = (start / totalDur * 100) + '%';
                timeRegion.style.width = ((end - start) / totalDur * 100) + '%';
              } else {
                timeRegion.style.left = '0%';
                timeRegion.style.width = '100%';
              }
              timePlayhead.style.left = (totalDur > 0 ? (start / totalDur * 100) : 0) + '%';
            }

            // Default to first row chip if it's the only one, otherwise full file
            const rowChips = bar.querySelectorAll('.row-chip:not(.full-chip)');
            if (rowChips.length === 1) {
              const chip = rowChips[0];
              chip.classList.add('row-chip-active');
              const s = parseFloat(chip.dataset.start);
              const d = parseFloat(chip.dataset.dur);
              audio.src = `/audio/${aid}/window?start_seconds=${s}&duration_seconds=${d}`;
              updateTimeBar(s, s + d);
            } else {
              audio.src = `/audio/${aid}/download`;
              updateTimeBar(0, totalDur);
            }

            // Playhead tracking
            audio.addEventListener('timeupdate', () => {
              if (totalDur > 0) {
                const absTime = selStart + audio.currentTime;
                timePlayhead.style.left = (absTime / totalDur * 100) + '%';
              }
            });

            playBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              if (audio.paused) { audio.play(); } else { audio.pause(); }
            });
            audio.addEventListener('play', () => { playBtn.textContent = '\u23F8'; });
            audio.addEventListener('pause', () => { playBtn.textContent = '\u25B6'; });
            audio.addEventListener('ended', () => { playBtn.textContent = '\u25B6'; });

            bar.querySelectorAll('.row-chip:not(.full-chip)').forEach(chip => {
              chip.addEventListener('click', (e) => {
                e.stopPropagation();
                bar.querySelectorAll('.row-chip').forEach(c => c.classList.remove('row-chip-active'));
                chip.classList.add('row-chip-active');
                const s = parseFloat(chip.dataset.start);
                const d = parseFloat(chip.dataset.dur);
                updateTimeBar(s, s + d);
                audio.src = `/audio/${aid}/window?start_seconds=${s}&duration_seconds=${d}`;
                audio.play();
              });
            });

            const fullChip = bar.querySelector('.full-chip');
            fullChip.addEventListener('click', (e) => {
              e.stopPropagation();
              bar.querySelectorAll('.row-chip').forEach(c => c.classList.remove('row-chip-active'));
              fullChip.classList.add('row-chip-active');
              updateTimeBar(0, totalDur);
              audio.src = `/audio/${aid}/download`;
              audio.play();
            });

            volSlider.addEventListener('input', (e) => {
              e.stopPropagation();
              audio.volume = volSlider.value;
            });
          });

          const detailHtml = treeContainer.innerHTML;
          expandedClusters.set(cid, detailHtml);
          const tr = document.createElement('tr');
          tr.className = 'assignment-row';
          tr.dataset.clusterId = cid;
          const td = document.createElement('td');
          td.colSpan = 3;
          td.appendChild(treeContainer);
          tr.appendChild(td);
          row.after(tr);
        } catch (e) { console.error(e); }
      });
    });
  } catch (e) { console.error(e); }
}

let clusterJobIds = [];

async function loadAllClusterJobs() {
  try {
    const jobs = await api('/clustering/jobs');
    // Merge server-side job IDs into our local list (preserving order, deduplicating)
    const existing = new Set(clusterJobIds);
    for (const j of jobs) {
      if (!existing.has(j.id)) {
        clusterJobIds.push(j.id);
        existing.add(j.id);
      }
    }
    loadClusterJobs();
  } catch (e) { console.error(e); }
}

function buildClusterParams() {
  const params = {};
  const minSize = parseInt($('#cluster-min-size').value);
  if (minSize && minSize >= 2) params.min_cluster_size = minSize;
  const minSamples = $('#cluster-min-samples').value;
  if (minSamples !== '') params.min_samples = parseInt(minSamples);
  params.use_umap = $('#cluster-use-umap').checked;
  if (params.use_umap) {
    params.umap_n_components = parseInt($('#cluster-umap-components').value) || 2;
    params.umap_n_neighbors = parseInt($('#cluster-umap-neighbors').value) || 15;
    params.umap_min_dist = parseFloat($('#cluster-umap-min-dist').value) || 0.1;
  }
  return params;
}

$('#queue-cluster-btn').addEventListener('click', async () => {
  const checkedBoxes = [...$('#cluster-embed-list').querySelectorAll('input:checked')];
  const checked = checkedBoxes.map(cb => cb.value);
  if (checked.length === 0) { showMsg('cluster-msg', 'Select at least one embedding set', 'error'); return; }

  // Client-side dimension validation
  const dims = new Set(checkedBoxes.map(cb => cb.dataset.dim));
  if (dims.size > 1) {
    showMsg('cluster-msg', `Cannot cluster embedding sets with different dimensions: ${[...dims].join(', ')}`, 'error');
    return;
  }

  const params = buildClusterParams();
  try {
    const result = await api('/clustering/jobs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ embedding_set_ids: checked, parameters: params }),
    });
    clusterJobIds.unshift(result.id);
    clusterJobsHavePending = true;
    showMsg('cluster-msg', `Clustering job queued: ${shortId(result.id)}`);
    loadClusterJobs();
  } catch (e) {
    showMsg('cluster-msg', `Failed: ${e.message}`, 'error');
  }
});

// ---- UMAP Plot Toggle ----
const umapPlotCache = {};

async function toggleUmapPlot(jobId, event) {
  if (event) event.stopPropagation();
  const container = document.getElementById(`umap-plot-${jobId}`);
  if (!container) return;

  // Toggle visibility
  if (container.style.display !== 'none' && container.innerHTML !== '') {
    container.style.display = 'none';
    return;
  }
  container.style.display = 'block';

  // If already rendered, just show
  if (umapPlotCache[jobId]) return;

  try {
    const data = await api(`/clustering/jobs/${jobId}/visualization`);
    umapPlotCache[jobId] = true;

    // Group points by cluster_label
    const groups = {};
    for (let i = 0; i < data.x.length; i++) {
      const label = data.cluster_label[i];
      if (!groups[label]) groups[label] = { x: [], y: [], text: [] };
      groups[label].x.push(data.x[i]);
      groups[label].y.push(data.y[i]);
      const fname = (data.audio_filename && data.audio_filename[i]) ? data.audio_filename[i].replace(/\.\w+$/, '') : `ES: ${data.embedding_set_id[i].slice(0,8)}â€¦`;
      groups[label].text.push(`${fname} (row ${data.embedding_row_index[i]})`);
    }

    const palette = ['#3a86ff','#e63946','#2a9d8f','#e9c46a','#264653','#f4a261','#6c5ce7','#00b894','#fd79a8','#636e72','#d63031','#74b9ff','#a29bfe','#ffeaa7','#55efc4'];
    const traces = [];
    const sortedLabels = Object.keys(groups).map(Number).sort((a, b) => a - b);

    for (const label of sortedLabels) {
      const g = groups[label];
      const isNoise = label === -1;
      traces.push({
        x: g.x, y: g.y, text: g.text,
        mode: 'markers',
        type: 'scatter',
        name: isNoise ? 'Noise' : `Cluster ${label}`,
        marker: {
          color: isNoise ? '#b2bec3' : palette[label % palette.length],
          size: isNoise ? 4 : 7,
          opacity: isNoise ? 0.4 : 0.8,
        },
        hoverinfo: 'text+name',
      });
    }

    const layout = {
      xaxis: { title: 'UMAP 1' },
      yaxis: { title: 'UMAP 2' },
      legend: { orientation: 'v', x: 1.02, y: 1 },
      margin: { l: 50, r: 120, t: 20, b: 50 },
      hovermode: 'closest',
    };

    Plotly.newPlot(container, traces, layout, { responsive: true });
  } catch (err) {
    if (err.message && err.message.includes('404')) {
      container.innerHTML = '<div class="umap-no-data">No UMAP data available for this job.</div>';
    } else {
      container.innerHTML = '<div class="umap-no-data">Failed to load UMAP plot.</div>';
    }
    umapPlotCache[jobId] = true;
  }
}

// ---- Export Cluster Report ----
async function exportClusterReport(jobId) {
  try {
    const [vizData, metrics] = await Promise.all([
      api(`/clustering/jobs/${jobId}/visualization`),
      api(`/clustering/jobs/${jobId}/metrics`),
    ]);

    // Build UMAP traces (same logic as toggleUmapPlot)
    const groups = {};
    for (let i = 0; i < vizData.x.length; i++) {
      const label = vizData.cluster_label[i];
      if (!groups[label]) groups[label] = { x: [], y: [], text: [] };
      groups[label].x.push(vizData.x[i]);
      groups[label].y.push(vizData.y[i]);
      const fname = (vizData.audio_filename && vizData.audio_filename[i]) ? vizData.audio_filename[i].replace(/\.\w+$/, '') : `ES: ${vizData.embedding_set_id[i].slice(0,8)}`;
      groups[label].text.push(`${fname} (row ${vizData.embedding_row_index[i]})`);
    }
    const palette = ['#3a86ff','#e63946','#2a9d8f','#e9c46a','#264653','#f4a261','#6c5ce7','#00b894','#fd79a8','#636e72','#d63031','#74b9ff','#a29bfe','#ffeaa7','#55efc4'];
    const traces = [];
    const sortedLabels = Object.keys(groups).map(Number).sort((a, b) => a - b);
    for (const label of sortedLabels) {
      const g = groups[label];
      const isNoise = label === -1;
      traces.push({
        x: g.x, y: g.y, text: g.text,
        mode: 'markers', type: 'scatter',
        name: isNoise ? 'Noise' : `Cluster ${label}`,
        marker: { color: isNoise ? '#b2bec3' : palette[label % palette.length], size: isNoise ? 4 : 7, opacity: isNoise ? 0.4 : 0.8 },
        hoverinfo: 'text+name',
      });
    }
    const layout = { xaxis: { title: 'UMAP 1' }, yaxis: { title: 'UMAP 2' }, legend: { orientation: 'v', x: 1.02, y: 1 }, margin: { l: 50, r: 120, t: 20, b: 50 }, hovermode: 'closest' };

    // Build metrics table HTML
    let metricsHtml = '';
    if (metrics && Object.keys(metrics).length > 0) {
      const fmt = (v) => typeof v === 'number' ? v.toFixed(4) : v;
      let rows = '';
      for (const [key, val] of Object.entries(metrics)) {
        if (key === 'category_metrics' || typeof val === 'object') continue;
        rows += `<tr><td>${key}</td><td>${fmt(val)}</td></tr>`;
      }
      if (metrics.category_metrics) {
        for (const [key, val] of Object.entries(metrics.category_metrics)) {
          rows += `<tr><td>${key} (category)</td><td>${fmt(val)}</td></tr>`;
        }
      }
      metricsHtml = `<h2>Cluster Evaluation Metrics</h2>
        <table class="metrics-table"><thead><tr><th>Metric</th><th>Value</th></tr></thead><tbody>${rows}</tbody></table>`;
    }

    const sid = jobId.slice(0, 8);
    const html = `<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Cluster Report ${sid}</title>
<script src="https://cdn.plot.ly/plotly-basic-2.35.2.min.js"><\/script>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 960px; margin: 2rem auto; padding: 0 1rem; color: #222; }
  h1 { font-size: 1.4rem; }
  h2 { font-size: 1.1rem; margin-top: 2rem; }
  .metrics-table { border-collapse: collapse; width: 100%; max-width: 500px; }
  .metrics-table th, .metrics-table td { border: 1px solid #ddd; padding: 0.4rem 0.75rem; text-align: left; }
  .metrics-table th { background: #f5f5f5; }
  .metrics-table tr:nth-child(even) { background: #fafafa; }
</style></head><body>
<h1>Cluster Report &mdash; Job ${sid}</h1>
<div id="umap-plot" style="height:500px"></div>
${metricsHtml}
<p style="margin-top:2rem;font-size:0.8rem;color:#999">Generated ${new Date().toISOString().slice(0,16).replace('T',' ')}</p>
<script>
  Plotly.newPlot('umap-plot', ${JSON.stringify(traces)}, ${JSON.stringify(layout)}, {responsive: true});
<\/script>
</body></html>`;

    const blob = new Blob([html], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `cluster_report_${sid}.html`;
    a.click();
    URL.revokeObjectURL(url);
  } catch (err) {
    alert('Failed to export report: ' + err.message);
  }
}

// ---- Evaluation Panel ----
const evalCache = {};

async function toggleEvaluation(jobId, event) {
  if (event) event.stopPropagation();
  const panel = document.getElementById(`eval-panel-${jobId}`);
  if (!panel) return;

  if (panel.style.display !== 'none' && panel.innerHTML !== '') {
    panel.style.display = 'none';
    return;
  }
  panel.style.display = 'block';

  if (evalCache[jobId]) return;

  try {
    const [metrics, sweep] = await Promise.all([
      api(`/clustering/jobs/${jobId}/metrics`).catch(() => ({})),
      api(`/clustering/jobs/${jobId}/parameter-sweep`).catch(() => []),
    ]);

    evalCache[jobId] = true;

    // Build metrics table
    const metricRows = [
      ['Silhouette Score', metrics.silhouette_score],
      ['Davies-Bouldin Index', metrics.davies_bouldin_index],
      ['Calinski-Harabasz Score', metrics.calinski_harabasz_score],
      ['Clusters', metrics.n_clusters],
      ['Noise Points', metrics.noise_count],
    ];
    if (metrics.adjusted_rand_index !== undefined) {
      metricRows.push(['Adjusted Rand Index', metrics.adjusted_rand_index]);
      metricRows.push(['Normalized Mutual Info', metrics.normalized_mutual_info]);
      metricRows.push(['Categories', metrics.n_categories]);
    }

    let html = '<h4 style="margin-bottom:0.5rem;font-size:0.9rem">Cluster Evaluation Metrics</h4>';
    html += '<table style="max-width:400px"><thead><tr><th>Metric</th><th>Value</th></tr></thead><tbody>';
    for (const [name, val] of metricRows) {
      const display = val === null || val === undefined ? '-' : (typeof val === 'number' ? val.toFixed(4) : val);
      html += `<tr><td>${name}</td><td>${display}</td></tr>`;
    }
    html += '</tbody></table>';

    // Add sweep chart container
    if (sweep && sweep.length > 0) {
      html += `<div id="sweep-chart-${jobId}" style="height:350px;margin-top:1rem"></div>`;
    }

    panel.innerHTML = html;

    // Render sweep chart
    if (sweep && sweep.length > 0) {
      const sweepContainer = document.getElementById(`sweep-chart-${jobId}`);
      const xVals = sweep.map(s => s.min_cluster_size);
      const silVals = sweep.map(s => s.silhouette_score);
      const nClusters = sweep.map(s => s.n_clusters);

      const traces = [
        {
          x: xVals, y: silVals,
          name: 'Silhouette Score',
          type: 'scatter', mode: 'lines+markers',
          marker: { color: '#3a86ff' },
          connectgaps: false,
        },
        {
          x: xVals, y: nClusters,
          name: 'N Clusters',
          type: 'scatter', mode: 'lines+markers',
          yaxis: 'y2',
          marker: { color: '#e63946' },
        },
      ];

      const layout = {
        xaxis: { title: 'min_cluster_size' },
        yaxis: { title: 'Silhouette Score', side: 'left' },
        yaxis2: { title: 'N Clusters', overlaying: 'y', side: 'right' },
        legend: { orientation: 'h', y: -0.2 },
        margin: { l: 60, r: 60, t: 20, b: 60 },
        hovermode: 'x unified',
      };

      Plotly.newPlot(sweepContainer, traces, layout, { responsive: true });
    }
  } catch (err) {
    panel.innerHTML = '<div class="msg msg-error">Failed to load evaluation data.</div>';
    evalCache[jobId] = true;
  }
}

// ---- Polling for running jobs ----
let clusterJobsHavePending = false;
setInterval(() => {
  const activeTab = document.querySelector('.tab-btn.active')?.dataset.tab;
  if (activeTab === 'processing') { loadProcJobs(); loadEmbeddingSets(); }
  if (activeTab === 'clustering' && clusterJobsHavePending) loadClusterJobs();
}, 3000);

// ==================== ADMIN ====================
async function loadAdminModels() {
  try {
    const models = await api('/admin/models');
    const tbody = $('#admin-models-body');
    if (models.length === 0) {
      tbody.innerHTML = '';
      $('#admin-models-empty').classList.remove('hidden');
      return;
    }
    $('#admin-models-empty').classList.add('hidden');
    tbody.innerHTML = models.map(m => `
      <tr>
        <td>${m.name}</td>
        <td>${m.display_name}</td>
        <td style="font-size:0.8rem">${m.path}</td>
        <td>${m.model_type || 'tflite'}</td>
        <td>${m.input_format || 'spectrogram'}</td>
        <td>${m.vector_dim}</td>
        <td>${m.is_default ? '<strong>Yes</strong>' : 'No'}</td>
        <td>
          ${!m.is_default ? `<button class="btn btn-sm btn-primary set-default-model" data-id="${m.id}">Set Default</button>` : ''}
          <button class="btn btn-sm btn-danger delete-model" data-id="${m.id}" style="margin-left:0.25rem">Delete</button>
        </td>
      </tr>`).join('');

    tbody.querySelectorAll('.set-default-model').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        try {
          await api(`/admin/models/${btn.dataset.id}/set-default`, { method: 'POST' });
          loadAdminModels();
        } catch (err) { showMsg('admin-models-msg', `Failed: ${err.message}`, 'error'); }
      });
    });
    tbody.querySelectorAll('.delete-model').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (!confirm('Delete this model from the registry?')) return;
        try {
          await api(`/admin/models/${btn.dataset.id}`, { method: 'DELETE' });
          showMsg('admin-models-msg', 'Model deleted');
          loadAdminModels();
        } catch (err) { showMsg('admin-models-msg', `Failed: ${err.message}`, 'error'); }
      });
    });
  } catch (e) { console.error(e); }
}

$('#scan-models-btn').addEventListener('click', async () => {
  try {
    const files = await api('/admin/models/scan');
    const unregistered = files.filter(f => !f.registered);
    const container = $('#scan-results');
    const list = $('#scan-results-list');
    if (unregistered.length === 0) {
      container.classList.remove('hidden');
      list.innerHTML = '<p class="empty">All model files are already registered.</p>';
      return;
    }
    container.classList.remove('hidden');
    list.innerHTML = unregistered.map((f, i) => `
      <div class="card" style="padding:0.75rem;margin-bottom:0.5rem">
        <strong>${f.filename}</strong> <span style="font-size:0.8rem;color:#888">(${(f.size_bytes / 1024 / 1024).toFixed(1)} MB)</span>
        <span class="badge" style="margin-left:0.5rem;background:#e0e7ff;color:#3730a3">${f.model_type || 'tflite'}</span>
        <div class="form-row" style="margin-top:0.5rem">
          <div class="form-group">
            <label>Name (identifier)</label>
            <input type="text" id="scan-name-${i}" value="${f.filename.replace('.tflite', '').replace(/[^a-zA-Z0-9_-]/g, '_')}" style="width:100%">
          </div>
          <div class="form-group">
            <label>Display Name</label>
            <input type="text" id="scan-display-${i}" value="${f.filename.replace('.tflite', '').replace(/[_-]/g, ' ')}" style="width:100%">
          </div>
          <div class="form-group">
            <label>Vector Dim</label>
            <input type="number" id="scan-dim-${i}" value="1280" min="1" style="width:100%">
          </div>
          <div class="form-group" style="display:flex;align-items:flex-end">
            <button class="btn btn-primary btn-sm register-scanned" data-index="${i}" data-path="${f.path}" data-model-type="${f.model_type || 'tflite'}" data-input-format="${f.input_format || 'spectrogram'}">Register</button>
          </div>
        </div>
      </div>`).join('');

    list.querySelectorAll('.register-scanned').forEach(btn => {
      btn.addEventListener('click', async () => {
        const idx = btn.dataset.index;
        const body = {
          name: $(`#scan-name-${idx}`).value,
          display_name: $(`#scan-display-${idx}`).value,
          path: btn.dataset.path,
          vector_dim: parseInt($(`#scan-dim-${idx}`).value),
          model_type: btn.dataset.modelType || 'tflite',
          input_format: btn.dataset.inputFormat || 'spectrogram',
        };
        try {
          await api('/admin/models', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });
          showMsg('admin-models-msg', `Registered: ${body.name}`);
          loadAdminModels();
          btn.closest('.card').remove();
        } catch (e) { showMsg('admin-models-msg', `Failed: ${e.message}`, 'error'); }
      });
    });
  } catch (e) { showMsg('admin-models-msg', `Scan failed: ${e.message}`, 'error'); }
});

async function loadAdminTables() {
  try {
    const tables = await api('/admin/tables');
    const tbody = $('#admin-table-body');
    if (tables.length === 0) {
      tbody.innerHTML = '';
      $('#admin-empty').classList.remove('hidden');
      return;
    }
    $('#admin-empty').classList.add('hidden');
    tbody.innerHTML = tables.map(t => `
      <tr>
        <td>${t.table}</td>
        <td>${t.count}</td>
      </tr>`).join('');
  } catch (e) { console.error(e); }
}

$('#delete-all-btn').addEventListener('click', async () => {
  if (!confirm('This will permanently delete ALL records from the database. Are you sure?')) return;
  try {
    await api('/admin/tables', { method: 'DELETE' });
    showMsg('admin-msg', 'All records deleted');
    loadAdminTables();
  } catch (e) {
    showMsg('admin-msg', `Failed: ${e.message}`, 'error');
  }
});

// ---- Initial load ----
loadAudioList();
</script>
</body>
</html>
