<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Humpback Acoustic Embedding Platform</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #f5f7fa; color: #1a1a2e; }
header { background: #1a1a2e; color: #fff; padding: 1rem 2rem; display: flex; align-items: center; gap: 1rem; }
header h1 { font-size: 1.25rem; font-weight: 600; }
.tabs { display: flex; gap: 0; border-bottom: 2px solid #ddd; background: #fff; padding: 0 2rem; }
.tab-btn { padding: 0.75rem 1.5rem; border: none; background: none; cursor: pointer; font-size: 0.95rem; color: #666; border-bottom: 2px solid transparent; margin-bottom: -2px; }
.tab-btn.active { color: #1a1a2e; border-bottom-color: #3a86ff; font-weight: 600; }
.tab-content { display: none; padding: 1.5rem 2rem; max-width: 1100px; }
.tab-content.active { display: block; }
.card { background: #fff; border-radius: 8px; padding: 1.25rem; margin-bottom: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
.card h3 { margin-bottom: 0.75rem; font-size: 1rem; }
table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
th, td { text-align: left; padding: 0.5rem 0.75rem; border-bottom: 1px solid #eee; }
th { font-weight: 600; color: #555; font-size: 0.8rem; text-transform: uppercase; }
tr:hover { background: #f9f9ff; }
tr { cursor: pointer; }
button, .btn { padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; }
.btn-primary { background: #3a86ff; color: #fff; }
.btn-primary:hover { background: #2a76ef; }
.btn-danger { background: #e63946; color: #fff; }
.btn-danger:hover { background: #c5303c; }
.btn-sm { padding: 0.25rem 0.6rem; font-size: 0.8rem; }
input, select, textarea { padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9rem; font-family: inherit; }
textarea { resize: vertical; }
label { font-size: 0.85rem; font-weight: 600; display: block; margin-bottom: 0.25rem; color: #444; }
.form-group { margin-bottom: 0.75rem; }
.form-row { display: flex; gap: 1rem; flex-wrap: wrap; }
.form-row .form-group { flex: 1; min-width: 180px; }
.badge { display: inline-block; padding: 0.15rem 0.5rem; border-radius: 10px; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; }
.badge-queued { background: #ffeaa7; color: #856404; }
.badge-running { background: #81ecec; color: #0c5460; }
.badge-complete { background: #a8e6cf; color: #155724; }
.badge-failed { background: #ff7675; color: #721c24; }
.badge-canceled { background: #dfe6e9; color: #636e72; }
.drop-zone { border: 2px dashed #ccc; border-radius: 8px; padding: 2rem; text-align: center; color: #888; transition: all 0.2s; }
.drop-zone.over { border-color: #3a86ff; background: #f0f6ff; color: #3a86ff; }
.drop-zone input[type="file"] { display: none; }
.detail-panel { background: #fff; border-radius: 8px; padding: 1.25rem; margin-bottom: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
.detail-panel .back-link { cursor: pointer; color: #3a86ff; font-size: 0.85rem; margin-bottom: 0.75rem; display: inline-block; }
.msg { padding: 0.75rem; border-radius: 4px; margin-bottom: 0.75rem; font-size: 0.9rem; }
.msg-success { background: #d4edda; color: #155724; }
.msg-error { background: #f8d7da; color: #721c24; }
.hidden { display: none !important; }
.empty { color: #999; font-style: italic; padding: 1rem 0; }
.checkbox-list { max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px; padding: 0.5rem; }
.checkbox-list label { font-weight: normal; display: flex; align-items: center; gap: 0.5rem; padding: 0.25rem 0; cursor: pointer; }
.upload-progress { margin-top: 0.75rem; }
.upload-progress .bar-track { background: #eee; border-radius: 4px; height: 6px; overflow: hidden; }
.upload-progress .bar-fill { background: #3a86ff; height: 100%; width: 0%; transition: width 0.3s; }
.upload-progress .bar-label { font-size: 0.8rem; color: #666; margin-top: 0.25rem; }
.tree-folder { margin-left: 0.5rem; }
.tree-folder-header { display: flex; align-items: center; gap: 0.4rem; padding: 0.3rem 0.25rem; cursor: pointer; font-weight: 600; font-size: 0.9rem; color: #333; user-select: none; border-radius: 4px; }
.tree-folder-header:hover { background: #f0f4ff; }
.tree-folder-header .arrow { display: inline-block; width: 1rem; text-align: center; font-size: 0.7rem; transition: transform 0.15s; color: #888; }
.tree-folder-header .arrow.open { transform: rotate(90deg); }
.tree-folder-children { margin-left: 1rem; border-left: 1px solid #e0e0e0; padding-left: 0.25rem; }
.tree-folder-children.collapsed { display: none; }
.tree-file-row { display: flex; align-items: center; gap: 0.75rem; padding: 0.3rem 0.5rem; font-size: 0.88rem; border-radius: 4px; cursor: pointer; }
.tree-file-row:hover { background: #f0f6ff; }
.tree-file-row .file-icon { color: #888; font-size: 0.8rem; }
.tree-file-row .file-name { flex: 1; }
.tree-file-row .file-meta { color: #888; font-size: 0.8rem; white-space: nowrap; }
.tree-root { margin-top: 0.5rem; }
</style>
</head>
<body>

<header>
  <h1>Humpback Acoustic Embedding Platform</h1>
</header>

<div class="tabs">
  <button class="tab-btn active" data-tab="audio">Audio</button>
  <button class="tab-btn" data-tab="processing">Processing</button>
  <button class="tab-btn" data-tab="clustering">Clustering</button>
  <button class="tab-btn" data-tab="admin">Admin</button>
</div>

<!-- ==================== AUDIO TAB ==================== -->
<div id="audio" class="tab-content active">
  <div id="audio-list-view">
    <div class="card">
      <h3>Upload Audio</h3>
      <div class="drop-zone" id="drop-zone">
        <p>Drag &amp; drop audio files or a folder here, or <a href="#" id="browse-link">browse files</a> / <a href="#" id="browse-folder-link">browse folder</a></p>
        <input type="file" id="audio-file-input" accept=".wav,.mp3" multiple>
        <input type="file" id="audio-folder-input" accept=".wav,.mp3" webkitdirectory multiple>
      </div>
      <div id="upload-progress" class="upload-progress hidden">
        <div class="bar-track"><div class="bar-fill" id="upload-bar"></div></div>
        <div class="bar-label" id="upload-bar-label"></div>
      </div>
      <div id="upload-msg"></div>
    </div>
    <div class="card">
      <h3>Audio Files</h3>
      <div id="audio-tree-container" class="tree-root"></div>
      <p id="audio-empty" class="empty hidden">No audio files uploaded yet.</p>
    </div>
  </div>

  <div id="audio-detail-view" class="hidden">
    <div class="detail-panel">
      <span class="back-link" id="audio-back">&larr; Back to list</span>
      <h3 id="audio-detail-title"></h3>
      <table id="audio-detail-info"><tbody></tbody></table>
    </div>
    <div class="detail-panel">
      <h3>Metadata</h3>
      <div class="form-group">
        <label>Tag Data (JSON)</label>
        <textarea id="meta-tag-data" rows="2" style="width:100%">{}</textarea>
      </div>
      <div class="form-group">
        <label>Visual Observations (JSON)</label>
        <textarea id="meta-visual" rows="2" style="width:100%">{}</textarea>
      </div>
      <div class="form-group">
        <label>Group Composition (JSON)</label>
        <textarea id="meta-group" rows="2" style="width:100%">{}</textarea>
      </div>
      <div class="form-group">
        <label>Prey Density Proxy (JSON)</label>
        <textarea id="meta-prey" rows="2" style="width:100%">{}</textarea>
      </div>
      <button class="btn btn-primary" id="save-meta-btn">Save Metadata</button>
      <div id="meta-msg"></div>
    </div>
    <div class="detail-panel">
      <h3>Processing History</h3>
      <table>
        <thead><tr><th>Job ID</th><th>Status</th><th>Model</th><th>Window</th><th>Created</th></tr></thead>
        <tbody id="audio-proc-history"></tbody>
      </table>
      <p id="audio-proc-empty" class="empty hidden">No processing jobs for this file.</p>
    </div>
  </div>
</div>

<!-- ==================== PROCESSING TAB ==================== -->
<div id="processing" class="tab-content">
  <div class="card">
    <h3>Queue Processing Job</h3>
    <div class="form-row">
      <div class="form-group">
        <label>Audio File</label>
        <select id="proc-audio-select"><option value="">-- select --</option></select>
      </div>
      <div class="form-group">
        <label>Model Version</label>
        <select id="proc-model"><option value="">-- loading --</option></select>
      </div>
      <div class="form-group">
        <label>Window Size (s)</label>
        <input type="number" id="proc-window" value="5" step="0.5" min="0.5">
      </div>
      <div class="form-group">
        <label>Sample Rate</label>
        <input type="number" id="proc-rate" value="32000" min="8000">
      </div>
    </div>
    <button class="btn btn-primary" id="queue-proc-btn">Queue Job</button>
    <button class="btn btn-primary" id="queue-all-proc-btn" style="margin-left:0.5rem">Queue All Unprocessed</button>
    <div id="proc-msg"></div>
    <div id="proc-batch-progress" class="upload-progress hidden">
      <div class="bar-track"><div class="bar-fill" id="proc-batch-bar"></div></div>
      <div class="bar-label" id="proc-batch-label"></div>
    </div>
  </div>
  <div class="card">
    <h3>Processing Jobs</h3>
    <div id="proc-tree-container" class="tree-root"></div>
    <p id="proc-empty" class="empty hidden">No processing jobs.</p>
  </div>
  <div class="card">
    <h3>Embedding Sets</h3>
    <div id="embed-tree-container" class="tree-root"></div>
    <p id="embed-empty" class="empty hidden">No embedding sets.</p>
  </div>
</div>

<!-- ==================== CLUSTERING TAB ==================== -->
<div id="clustering" class="tab-content">
  <div class="card">
    <h3>Queue Clustering Job</h3>
    <div class="form-group">
      <label>Select Embedding Sets</label>
      <button type="button" class="btn" id="cluster-toggle-all-btn" style="margin-bottom:0.5em;font-size:0.85em;padding:0.25em 0.75em;">Select All</button>
      <div class="checkbox-list" id="cluster-embed-list"></div>
      <p id="cluster-embed-empty" class="empty hidden">No embedding sets available.</p>
    </div>
    <h4 style="margin-top:0.75rem;margin-bottom:0.5rem;font-size:0.9rem">HDBSCAN Parameters</h4>
    <div class="form-row">
      <div class="form-group">
        <label>Min Cluster Size</label>
        <input type="number" id="cluster-min-size" value="5" min="2" step="1">
      </div>
      <div class="form-group">
        <label>Min Samples <span style="font-weight:normal;color:#888">(optional)</span></label>
        <input type="number" id="cluster-min-samples" value="" min="1" step="1" placeholder="default: min_cluster_size">
      </div>
    </div>
    <h4 style="margin-top:0.5rem;margin-bottom:0.5rem;font-size:0.9rem">UMAP Dimensionality Reduction</h4>
    <div class="form-row">
      <div class="form-group">
        <label><input type="checkbox" id="cluster-use-umap" checked style="margin-right:0.4rem">Enable UMAP</label>
      </div>
      <div class="form-group">
        <label>Components</label>
        <input type="number" id="cluster-umap-components" value="2" min="2" max="50" step="1">
      </div>
      <div class="form-group">
        <label>Neighbors</label>
        <input type="number" id="cluster-umap-neighbors" value="15" min="2" max="200" step="1">
      </div>
      <div class="form-group">
        <label>Min Distance</label>
        <input type="number" id="cluster-umap-min-dist" value="0.1" min="0" max="1" step="0.01">
      </div>
    </div>
    <button class="btn btn-primary" id="queue-cluster-btn">Queue Clustering Job</button>
    <div id="cluster-msg"></div>
  </div>
  <div class="card">
    <h3>Clustering Jobs</h3>
    <div id="cluster-jobs-container"></div>
    <p id="cluster-jobs-empty" class="empty hidden">No clustering jobs.</p>
  </div>
</div>

<!-- ==================== ADMIN TAB ==================== -->
<div id="admin" class="tab-content">
  <div class="card">
    <h3>Model Registry</h3>
    <table>
      <thead><tr><th>Name</th><th>Display Name</th><th>Path</th><th>Dims</th><th>Default</th><th></th></tr></thead>
      <tbody id="admin-models-body"></tbody>
    </table>
    <p id="admin-models-empty" class="empty hidden">No models registered.</p>
    <div style="margin-top:0.75rem">
      <button class="btn btn-primary" id="scan-models-btn">Scan for Models</button>
    </div>
    <div id="scan-results" class="hidden" style="margin-top:0.75rem">
      <h4 style="font-size:0.9rem;margin-bottom:0.5rem">Unregistered .tflite Files</h4>
      <div id="scan-results-list"></div>
    </div>
    <div id="admin-models-msg"></div>
  </div>
  <div class="card">
    <h3>Database Tables</h3>
    <table>
      <thead><tr><th>Table</th><th>Row Count</th></tr></thead>
      <tbody id="admin-table-body"></tbody>
    </table>
    <p id="admin-empty" class="empty hidden">No tables found.</p>
    <div style="margin-top:1rem">
      <button class="btn btn-danger" id="delete-all-btn">Delete All Records</button>
    </div>
    <div id="admin-msg"></div>
  </div>
</div>

<script>
// ---- Helpers ----
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => document.querySelectorAll(sel);
const api = async (path, opts = {}) => {
  const res = await fetch(path, opts);
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`${res.status}: ${text}`);
  }
  return res.json();
};
const shortId = (id) => id.slice(0, 8);
const fmtDate = (d) => new Date(d).toLocaleString();
const badgeHtml = (status) => `<span class="badge badge-${status}">${status}</span>`;
const jsonPretty = (obj) => obj ? JSON.stringify(obj, null, 2) : '{}';

function showMsg(elId, text, type = 'success') {
  const el = document.getElementById(elId);
  el.innerHTML = `<div class="msg msg-${type}">${text}</div>`;
  setTimeout(() => el.innerHTML = '', 4000);
}

// ---- Tab switching ----
$$('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    $$('.tab-btn').forEach(b => b.classList.remove('active'));
    $$('.tab-content').forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    $('#' + btn.dataset.tab).classList.add('active');
    if (btn.dataset.tab === 'audio') loadAudioList();
    if (btn.dataset.tab === 'processing') { loadAudioOptions(); loadModelOptions(); loadProcJobs(); loadEmbeddingSets(); }
    if (btn.dataset.tab === 'clustering') { loadClusterEmbedOptions(); loadAllClusterJobs(); }
    if (btn.dataset.tab === 'admin') { loadAdminTables(); loadAdminModels(); }
  });
});

// ---- Audio file cache (id -> {filename, folder_path}) ----
let audioFileMap = {};

/**
 * Build an expandable folder tree from a list of items.
 * @param {Array} items - data items to display
 * @param {Function} getPath - (item) => folder path string (e.g. "a/b/c")
 * @param {Function} renderLeaf - (item) => HTML string for the leaf row
 * @param {Object} expandState - persistent object tracking open/closed folders
 * @param {HTMLElement} container - DOM element to render into
 */
function buildFolderTree(items, getPath, renderLeaf, expandState, container) {
  // Build trie structure
  const root = { children: {}, items: [] };
  for (const item of items) {
    const path = getPath(item);
    if (!path) {
      root.items.push(item);
      continue;
    }
    const parts = path.split('/');
    let node = root;
    for (const part of parts) {
      if (!node.children[part]) node.children[part] = { children: {}, items: [] };
      node = node.children[part];
    }
    node.items.push(item);
  }

  function renderNode(node, pathSoFar) {
    let html = '';
    // Render subfolders sorted alphabetically
    const folderNames = Object.keys(node.children).sort();
    for (const name of folderNames) {
      const fullPath = pathSoFar ? pathSoFar + '/' + name : name;
      const isOpen = expandState[fullPath] !== false; // default open
      const child = node.children[name];
      const count = countItems(child);
      html += `<div class="tree-folder">
        <div class="tree-folder-header" data-path="${fullPath}">
          <span class="arrow ${isOpen ? 'open' : ''}">\u25B6</span>
          <span>\uD83D\uDCC1 ${name}</span>
          <span style="color:#999;font-weight:normal;font-size:0.8rem">(${count})</span>
        </div>
        <div class="tree-folder-children ${isOpen ? '' : 'collapsed'}">
          ${renderNode(child, fullPath)}
        </div>
      </div>`;
    }
    // Render leaf items
    for (const item of node.items) {
      html += renderLeaf(item);
    }
    return html;
  }

  function countItems(node) {
    let c = node.items.length;
    for (const child of Object.values(node.children)) c += countItems(child);
    return c;
  }

  container.innerHTML = renderNode(root, '');

  // Attach expand/collapse handlers
  container.querySelectorAll('.tree-folder-header').forEach(header => {
    header.addEventListener('click', () => {
      const path = header.dataset.path;
      const children = header.nextElementSibling;
      const arrow = header.querySelector('.arrow');
      const isOpen = !children.classList.contains('collapsed');
      if (isOpen) {
        children.classList.add('collapsed');
        arrow.classList.remove('open');
        expandState[path] = false;
      } else {
        children.classList.remove('collapsed');
        arrow.classList.add('open');
        expandState[path] = true;
      }
    });
  });
}

// ==================== AUDIO ====================
const audioTreeExpand = {};

async function loadAudioList() {
  try {
    const files = await api('/audio/');
    audioFileMap = {};
    files.forEach(f => { audioFileMap[f.id] = { filename: f.filename, folder_path: f.folder_path || '' }; });
    const container = $('#audio-tree-container');
    if (files.length === 0) {
      container.innerHTML = '';
      $('#audio-empty').classList.remove('hidden');
      return;
    }
    $('#audio-empty').classList.add('hidden');

    buildFolderTree(
      files,
      f => f.folder_path || '',
      f => `<div class="tree-file-row" data-id="${f.id}">
        <span class="file-icon">\uD83C\uDFB5</span>
        <span class="file-name">${f.filename}</span>
        <span class="file-meta">${f.duration_seconds ? f.duration_seconds.toFixed(1) + 's' : '-'}</span>
        <span class="file-meta">${f.sample_rate_original ? f.sample_rate_original + ' Hz' : ''}</span>
        <span class="file-meta">${fmtDate(f.created_at)}</span>
      </div>`,
      audioTreeExpand,
      container,
    );

    container.querySelectorAll('.tree-file-row').forEach(row => {
      row.addEventListener('click', () => showAudioDetail(row.dataset.id));
    });
  } catch (e) { console.error(e); }
}

async function showAudioDetail(id) {
  try {
    const af = await api(`/audio/${id}`);
    $('#audio-list-view').classList.add('hidden');
    $('#audio-detail-view').classList.remove('hidden');
    $('#audio-detail-title').textContent = af.filename;
    $('#audio-detail-info tbody').innerHTML = `
      <tr><td><strong>ID</strong></td><td>${af.id}</td></tr>
      <tr><td><strong>SHA-256</strong></td><td style="word-break:break-all;font-size:0.8rem">${af.checksum_sha256}</td></tr>
      <tr><td><strong>Duration</strong></td><td>${af.duration_seconds ? af.duration_seconds.toFixed(1) + 's' : '-'}</td></tr>
      <tr><td><strong>Sample Rate</strong></td><td>${af.sample_rate_original || '-'}</td></tr>
      <tr><td><strong>Created</strong></td><td>${fmtDate(af.created_at)}</td></tr>`;
    const m = af.metadata;
    $('#meta-tag-data').value = jsonPretty(m?.tag_data);
    $('#meta-visual').value = jsonPretty(m?.visual_observations);
    $('#meta-group').value = jsonPretty(m?.group_composition);
    $('#meta-prey').value = jsonPretty(m?.prey_density_proxy);
    $('#audio-detail-view').dataset.audioId = id;

    // Load processing history for this audio
    const jobs = await api('/processing/jobs');
    const related = jobs.filter(j => j.audio_file_id === id);
    const histTbody = $('#audio-proc-history');
    if (related.length === 0) {
      histTbody.innerHTML = '';
      $('#audio-proc-empty').classList.remove('hidden');
    } else {
      $('#audio-proc-empty').classList.add('hidden');
      histTbody.innerHTML = related.map(j => `
        <tr>
          <td>${shortId(j.id)}</td>
          <td>${badgeHtml(j.status)}</td>
          <td>${j.model_version}</td>
          <td>${j.window_size_seconds}s</td>
          <td>${fmtDate(j.created_at)}</td>
        </tr>`).join('');
    }
  } catch (e) { console.error(e); }
}

$('#audio-back').addEventListener('click', () => {
  $('#audio-detail-view').classList.add('hidden');
  $('#audio-list-view').classList.remove('hidden');
  loadAudioList();
});

// Upload
const dropZone = $('#drop-zone');
const fileInput = $('#audio-file-input');
const folderInput = $('#audio-folder-input');
const AUDIO_EXTENSIONS = ['.wav', '.mp3'];

function isAudioFile(file) {
  const name = file.name.toLowerCase();
  return AUDIO_EXTENSIONS.some(ext => name.endsWith(ext));
}

$('#browse-link').addEventListener('click', (e) => { e.preventDefault(); fileInput.click(); });
$('#browse-folder-link').addEventListener('click', (e) => { e.preventDefault(); folderInput.click(); });
dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('over'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('over'));

dropZone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dropZone.classList.remove('over');
  const items = e.dataTransfer.items;
  let files = [];
  if (items) {
    // Try to read directories via webkitGetAsEntry
    const entries = [];
    for (const item of items) {
      const entry = item.webkitGetAsEntry && item.webkitGetAsEntry();
      if (entry) entries.push(entry);
    }
    if (entries.some(en => en.isDirectory)) {
      files = await readEntriesRecursive(entries);
    } else {
      files = [...e.dataTransfer.files];
    }
  } else {
    files = [...e.dataTransfer.files];
  }
  const audioFiles = files.filter(isAudioFile);
  if (audioFiles.length > 0) uploadFiles(audioFiles);
});

function readEntriesRecursive(entries) {
  return new Promise((resolve) => {
    const files = [];
    let pending = 0;

    function readAllEntries(reader) {
      // Chromium returns at most 100 entries per readEntries call
      return new Promise((res) => {
        const all = [];
        function readBatch() {
          reader.readEntries(batch => {
            if (batch.length === 0) { res(all); return; }
            all.push(...batch);
            readBatch();
          });
        }
        readBatch();
      });
    }

    function readEntry(entry, parentPath) {
      if (entry.isFile) {
        pending++;
        entry.file(f => {
          // Attach the folder path so uploadFiles can use it
          f._folderPath = parentPath;
          files.push(f);
          if (--pending === 0) resolve(files);
        });
      } else if (entry.isDirectory) {
        pending++;
        const dirPath = parentPath ? parentPath + '/' + entry.name : entry.name;
        const reader = entry.createReader();
        readAllEntries(reader).then(subEntries => {
          for (const sub of subEntries) readEntry(sub, dirPath);
          if (--pending === 0) resolve(files);
        });
      }
    }
    for (const entry of entries) readEntry(entry, '');
    if (pending === 0) resolve(files);
  });
}

fileInput.addEventListener('change', () => {
  const files = [...fileInput.files].filter(isAudioFile);
  // No folder path for direct file selection
  if (files.length > 0) uploadFiles(files);
  fileInput.value = '';
});
folderInput.addEventListener('change', () => {
  const files = [...folderInput.files].filter(isAudioFile);
  // Capture folder path from webkitRelativePath
  for (const f of files) {
    const rel = f.webkitRelativePath || '';
    const parts = rel.split('/');
    if (parts.length > 1) {
      f._folderPath = parts.slice(0, -1).join('/');
    }
  }
  if (files.length > 0) uploadFiles(files);
  folderInput.value = '';
});

async function uploadFiles(files) {
  const total = files.length;
  if (total === 0) return;
  const progressEl = $('#upload-progress');
  const bar = $('#upload-bar');
  const label = $('#upload-bar-label');
  progressEl.classList.remove('hidden');
  let done = 0, failed = 0;
  for (const file of files) {
    try {
      const form = new FormData();
      form.append('file', file);
      const folderPath = file._folderPath || '';
      if (folderPath) form.append('folder_path', folderPath);
      await api('/audio/upload', { method: 'POST', body: form });
    } catch (e) {
      failed++;
    }
    done++;
    bar.style.width = Math.round((done / total) * 100) + '%';
    label.textContent = `${done} / ${total}${failed ? ` (${failed} failed)` : ''}`;
  }
  const msg = failed
    ? `Uploaded ${done - failed} of ${total} files (${failed} failed)`
    : `Uploaded ${total} file${total > 1 ? 's' : ''}`;
  showMsg('upload-msg', msg, failed ? 'error' : 'success');
  setTimeout(() => progressEl.classList.add('hidden'), 2000);
  loadAudioList();
}

// Save metadata
$('#save-meta-btn').addEventListener('click', async () => {
  const audioId = $('#audio-detail-view').dataset.audioId;
  try {
    const body = {
      tag_data: JSON.parse($('#meta-tag-data').value || 'null'),
      visual_observations: JSON.parse($('#meta-visual').value || 'null'),
      group_composition: JSON.parse($('#meta-group').value || 'null'),
      prey_density_proxy: JSON.parse($('#meta-prey').value || 'null'),
    };
    await api(`/audio/${audioId}/metadata`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    showMsg('meta-msg', 'Metadata saved');
  } catch (e) {
    showMsg('meta-msg', `Failed: ${e.message}`, 'error');
  }
});

// ==================== PROCESSING ====================
function audioDisplayName(id) {
  const info = audioFileMap[id];
  if (!info) return shortId(id);
  return info.folder_path ? info.folder_path + '/' + info.filename : info.filename;
}

async function loadAudioOptions() {
  try {
    const files = await api('/audio/');
    audioFileMap = {};
    files.forEach(f => { audioFileMap[f.id] = { filename: f.filename, folder_path: f.folder_path || '' }; });
    const sorted = [...files].sort((a, b) => {
      const pa = (a.folder_path || '') + '/' + a.filename;
      const pb = (b.folder_path || '') + '/' + b.filename;
      return pa.localeCompare(pb);
    });
    const sel = $('#proc-audio-select');
    sel.innerHTML = '<option value="">-- select --</option>' +
      sorted.map(f => {
        const display = f.folder_path ? f.folder_path + '/' + f.filename : f.filename;
        return `<option value="${f.id}">${display}</option>`;
      }).join('');
  } catch (e) { console.error(e); }
}

async function loadModelOptions() {
  try {
    const models = await api('/admin/models');
    const sel = $('#proc-model');
    sel.innerHTML = models.map(m =>
      `<option value="${m.name}"${m.is_default ? ' selected' : ''}>${m.display_name} (${m.vector_dim}d)</option>`
    ).join('');
    if (models.length === 0) sel.innerHTML = '<option value="">-- no models registered --</option>';
  } catch (e) { console.error(e); }
}

const procTreeExpand = {};
const embedTreeExpand = {};

async function loadProcJobs() {
  try {
    const jobs = await api('/processing/jobs');
    const container = $('#proc-tree-container');
    if (jobs.length === 0) {
      container.innerHTML = '';
      $('#proc-empty').classList.remove('hidden');
      return;
    }
    $('#proc-empty').classList.add('hidden');

    buildFolderTree(
      jobs,
      j => {
        const info = audioFileMap[j.audio_file_id];
        return info ? info.folder_path : '';
      },
      j => {
        const audioName = audioDisplayName(j.audio_file_id);
        const cancelBtn = (j.status === 'queued' || j.status === 'running')
          ? `<button class="btn btn-danger btn-sm cancel-proc" data-id="${j.id}" style="margin-left:0.5rem">Cancel</button>` : '';
        return `<div class="tree-file-row" style="cursor:default">
          <span class="file-meta">${shortId(j.id)}</span>
          <span class="file-name">${audioFileMap[j.audio_file_id]?.filename || shortId(j.audio_file_id)}</span>
          <span>${badgeHtml(j.status)}</span>
          <span class="file-meta">${j.model_version}</span>
          <span class="file-meta">${j.window_size_seconds}s</span>
          <span class="file-meta">${fmtDate(j.created_at)}</span>
          ${cancelBtn}
        </div>`;
      },
      procTreeExpand,
      container,
    );

    container.querySelectorAll('.cancel-proc').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        try {
          await api(`/processing/jobs/${btn.dataset.id}/cancel`, { method: 'POST' });
          loadProcJobs();
        } catch (err) { console.error(err); }
      });
    });
  } catch (e) { console.error(e); }
}

async function loadEmbeddingSets() {
  try {
    const sets = await api('/processing/embedding-sets');
    const container = $('#embed-tree-container');
    if (sets.length === 0) {
      container.innerHTML = '';
      $('#embed-empty').classList.remove('hidden');
      return;
    }
    $('#embed-empty').classList.add('hidden');

    buildFolderTree(
      sets,
      s => {
        const info = audioFileMap[s.audio_file_id];
        return info ? info.folder_path : '';
      },
      s => `<div class="tree-file-row" style="cursor:default">
        <span class="file-meta">${shortId(s.id)}</span>
        <span class="file-name">${audioFileMap[s.audio_file_id]?.filename || shortId(s.audio_file_id)}</span>
        <span class="file-meta">${s.model_version}</span>
        <span class="file-meta">${s.vector_dim}d</span>
        <span class="file-meta">${fmtDate(s.created_at)}</span>
      </div>`,
      embedTreeExpand,
      container,
    );
  } catch (e) { console.error(e); }
}

$('#queue-proc-btn').addEventListener('click', async () => {
  const audioId = $('#proc-audio-select').value;
  if (!audioId) { showMsg('proc-msg', 'Select an audio file', 'error'); return; }
  try {
    const body = {
      audio_file_id: audioId,
      model_version: $('#proc-model').value,
      window_size_seconds: parseFloat($('#proc-window').value),
      target_sample_rate: parseInt($('#proc-rate').value),
    };
    const result = await api('/processing/jobs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    showMsg('proc-msg', result.skipped ? 'Job skipped (embeddings already exist)' : `Job queued: ${shortId(result.id)}`);
    loadProcJobs();
  } catch (e) {
    showMsg('proc-msg', `Failed: ${e.message}`, 'error');
  }
});

$('#queue-all-proc-btn').addEventListener('click', async () => {
  try {
    const files = await api('/audio/');
    const jobs = await api('/processing/jobs');
    const model = $('#proc-model').value;
    const window = parseFloat($('#proc-window').value);
    const rate = parseInt($('#proc-rate').value);

    // Find audio files that don't already have a non-failed job with these settings
    const existingAudioIds = new Set(
      jobs.filter(j => j.model_version === model
        && j.window_size_seconds === window
        && j.target_sample_rate === rate
        && j.status !== 'failed'
      ).map(j => j.audio_file_id)
    );
    const toQueue = files.filter(f => !existingAudioIds.has(f.id));

    if (toQueue.length === 0) {
      showMsg('proc-msg', 'All audio files already have jobs queued or completed');
      return;
    }

    const progressEl = $('#proc-batch-progress');
    const bar = $('#proc-batch-bar');
    const label = $('#proc-batch-label');
    progressEl.classList.remove('hidden');
    let done = 0, skipped = 0, failed = 0;

    for (const file of toQueue) {
      try {
        const result = await api('/processing/jobs', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            audio_file_id: file.id,
            model_version: model,
            window_size_seconds: window,
            target_sample_rate: rate,
          }),
        });
        if (result.skipped) skipped++;
      } catch (e) {
        failed++;
      }
      done++;
      bar.style.width = Math.round((done / toQueue.length) * 100) + '%';
      label.textContent = `Queued ${done} / ${toQueue.length}${skipped ? ` (${skipped} skipped)` : ''}${failed ? ` (${failed} failed)` : ''}`;
    }

    const queued = done - skipped - failed;
    showMsg('proc-msg', `Queued ${queued} jobs, ${skipped} skipped, ${failed} failed`);
    setTimeout(() => progressEl.classList.add('hidden'), 3000);
    loadProcJobs();
  } catch (e) {
    showMsg('proc-msg', `Failed: ${e.message}`, 'error');
  }
});

// ==================== CLUSTERING ====================
// Store embedding sets data for client-side dim validation
let clusterEmbedSetsData = [];

async function loadClusterEmbedOptions() {
  try {
    const sets = await api('/processing/embedding-sets');
    clusterEmbedSetsData = sets;
    const container = $('#cluster-embed-list');
    if (sets.length === 0) {
      container.innerHTML = '';
      $('#cluster-embed-empty').classList.remove('hidden');
      return;
    }
    $('#cluster-embed-empty').classList.add('hidden');

    // Group by model_version
    const groups = {};
    for (const s of sets) {
      const key = s.model_version;
      if (!groups[key]) groups[key] = { vector_dim: s.vector_dim, sets: [] };
      groups[key].sets.push(s);
    }

    let html = '';
    for (const [model, group] of Object.entries(groups)) {
      html += `<div style="margin-bottom:0.75rem">
        <div style="font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;display:flex;align-items:center;gap:0.5rem">
          ${model} (${group.vector_dim}d)
          <button type="button" class="btn btn-sm cluster-group-select-all" data-model="${model}" style="font-size:0.75rem;padding:0.15rem 0.5rem">Select All</button>
        </div>`;
      // Sort by folder_path/filename
      const sorted = [...group.sets].sort((a, b) => {
        const pa = audioDisplayName(a.audio_file_id);
        const pb = audioDisplayName(b.audio_file_id);
        return pa.localeCompare(pb);
      });
      for (const s of sorted) {
        html += `<label><input type="checkbox" value="${s.id}" data-dim="${s.vector_dim}" data-model="${model}">
          ${audioDisplayName(s.audio_file_id)}
        </label>`;
      }
      html += `</div>`;
    }
    container.innerHTML = html;

    // Per-group "Select All" buttons
    container.querySelectorAll('.cluster-group-select-all').forEach(btn => {
      btn.addEventListener('click', () => {
        const model = btn.dataset.model;
        const boxes = [...container.querySelectorAll(`input[data-model="${model}"]`)];
        const allChecked = boxes.every(cb => cb.checked);
        boxes.forEach(cb => cb.checked = !allChecked);
        btn.textContent = allChecked ? 'Select All' : 'Unselect All';
      });
    });
  } catch (e) { console.error(e); }
}

$('#cluster-toggle-all-btn').addEventListener('click', () => {
  const boxes = [...$('#cluster-embed-list').querySelectorAll('input[type="checkbox"]')];
  if (boxes.length === 0) return;
  const allChecked = boxes.every(cb => cb.checked);
  boxes.forEach(cb => cb.checked = !allChecked);
  $('#cluster-toggle-all-btn').textContent = allChecked ? 'Select All' : 'Unselect All';
});

// Track expanded cluster labels so they survive polling redraws
const expandedClusters = new Map(); // cluster_id -> assignments HTML
const clusterAssignTreeExpand = {}; // persist expand state for assignment trees

async function loadClusterJobs() {
  try {
    const container = $('#cluster-jobs-container');
    if (clusterJobIds.length === 0) {
      container.innerHTML = '';
      $('#cluster-jobs-empty').classList.remove('hidden');
      return;
    }
    $('#cluster-jobs-empty').classList.add('hidden');

    // Pre-fetch embedding sets for audio name resolution
    let embeddingSets = [];
    try { embeddingSets = await api('/processing/embedding-sets'); } catch (_) {}
    const esMap = {};
    embeddingSets.forEach(s => { esMap[s.id] = s; });

    let html = '';
    let hasPending = false;
    for (const jid of clusterJobIds) {
      try {
        const job = await api(`/clustering/jobs/${jid}`);
        if (job.status === 'queued' || job.status === 'running') hasPending = true;
        let clustersHtml = '';
        if (job.status === 'complete') {
          try {
            const clusters = await api(`/clustering/jobs/${jid}/clusters`);
            if (clusters.length > 0) {
              clustersHtml = `<table><thead><tr><th>Label</th><th>Size</th><th>Summary</th></tr></thead><tbody>` +
                clusters.map(c => {
                  const expanded = expandedClusters.has(c.id);
                  let rows = `<tr class="cluster-row" data-id="${c.id}" style="cursor:pointer">
                    <td>${c.cluster_label}</td><td>${c.size}</td>
                    <td style="font-size:0.8rem">${c.metadata_summary ? JSON.stringify(c.metadata_summary) : '-'}</td>
                  </tr>`;
                  if (expanded) {
                    rows += `<tr class="assignment-row" data-cluster-id="${c.id}">
                      <td colspan="3">${expandedClusters.get(c.id)}</td>
                    </tr>`;
                  }
                  return rows;
                }).join('') + `</tbody></table>`;
            }
          } catch (_) {}
        }
        const paramsSummary = job.parameters ? `<div style="font-size:0.8rem;color:#666;margin-top:0.25rem">${Object.entries(job.parameters).map(([k,v]) => `${k}=${v}`).join(', ')}</div>` : '';
        html += `<div class="card" style="margin-top:0.5rem">
          <strong>Job ${shortId(jid)}</strong> ${badgeHtml(job.status)}
          ${paramsSummary}
          ${job.error_message ? `<div class="msg msg-error" style="margin-top:0.5rem">${job.error_message}</div>` : ''}
          ${clustersHtml}
        </div>`;
      } catch (_) {}
    }
    clusterJobsHavePending = hasPending;
    container.innerHTML = html;
    // Create audio elements programmatically (innerHTML can break media elements)
    container.querySelectorAll('.audio-placeholder').forEach(span => {
      const aid = span.dataset.audioId;
      const audio = document.createElement('audio');
      audio.controls = true;
      audio.preload = 'metadata';
      audio.style.cssText = 'height:32px;max-width:260px';
      audio.src = `/audio/${aid}/download`;
      span.replaceWith(audio);
    });

    // Attach click handlers for cluster rows to toggle assignment details
    container.querySelectorAll('.cluster-row').forEach(row => {
      row.addEventListener('click', async () => {
        const cid = row.dataset.id;
        // Toggle off if already expanded
        if (expandedClusters.has(cid)) {
          expandedClusters.delete(cid);
          const next = row.nextElementSibling;
          if (next && next.classList.contains('assignment-row')) next.remove();
          return;
        }
        try {
          const assignments = await api(`/clustering/clusters/${cid}/assignments`);
          // Group assignments by embedding_set_id
          const byEs = {};
          for (const a of assignments) {
            if (!byEs[a.embedding_set_id]) byEs[a.embedding_set_id] = [];
            byEs[a.embedding_set_id].push(a.embedding_row_index);
          }

          // Build items with folder info for tree display
          const assignItems = [];
          for (const [esId, rowIndices] of Object.entries(byEs)) {
            const es = esMap[esId];
            const audioFileId = es ? es.audio_file_id : null;
            const info = audioFileId ? audioFileMap[audioFileId] : null;
            assignItems.push({
              esId,
              audioFileId,
              filename: info ? info.filename : (audioFileId ? shortId(audioFileId) : '-'),
              folder_path: info ? info.folder_path : '',
              rowIndices,
            });
          }

          // Build tree HTML
          const treeContainer = document.createElement('div');
          treeContainer.style.cssText = 'font-size:0.85rem;padding:0.5rem';
          treeContainer.innerHTML = `<strong>Assignments (${assignments.length}):</strong>`;
          const treeDiv = document.createElement('div');
          treeDiv.className = 'tree-root';
          treeContainer.appendChild(treeDiv);

          buildFolderTree(
            assignItems,
            item => item.folder_path,
            item => {
              const rowsDisplay = item.rowIndices.length > 20
                ? item.rowIndices.slice(0, 20).join(', ') + ` ... (${item.rowIndices.length} total)`
                : item.rowIndices.join(', ');
              const playerHtml = item.audioFileId
                ? `<span class="audio-placeholder" data-audio-id="${item.audioFileId}"></span>`
                : '';
              return `<div class="tree-file-row" style="cursor:default;flex-wrap:wrap">
                <span class="file-icon">\uD83C\uDFB5</span>
                <span class="file-name">${item.filename}</span>
                ${playerHtml}
                <span class="file-meta">rows: ${rowsDisplay}</span>
              </div>`;
            },
            clusterAssignTreeExpand,
            treeDiv,
          );

          // Replace audio placeholders
          treeContainer.querySelectorAll('.audio-placeholder').forEach(span => {
            const aid = span.dataset.audioId;
            const audio = document.createElement('audio');
            audio.controls = true;
            audio.preload = 'metadata';
            audio.style.cssText = 'height:32px;max-width:260px';
            audio.src = `/audio/${aid}/download`;
            span.replaceWith(audio);
          });

          const detailHtml = treeContainer.innerHTML;
          expandedClusters.set(cid, detailHtml);
          const tr = document.createElement('tr');
          tr.className = 'assignment-row';
          tr.dataset.clusterId = cid;
          const td = document.createElement('td');
          td.colSpan = 3;
          td.appendChild(treeContainer);
          tr.appendChild(td);
          row.after(tr);
        } catch (e) { console.error(e); }
      });
    });
  } catch (e) { console.error(e); }
}

let clusterJobIds = [];

async function loadAllClusterJobs() {
  try {
    const jobs = await api('/clustering/jobs');
    // Merge server-side job IDs into our local list (preserving order, deduplicating)
    const existing = new Set(clusterJobIds);
    for (const j of jobs) {
      if (!existing.has(j.id)) {
        clusterJobIds.push(j.id);
        existing.add(j.id);
      }
    }
    loadClusterJobs();
  } catch (e) { console.error(e); }
}

function buildClusterParams() {
  const params = {};
  const minSize = parseInt($('#cluster-min-size').value);
  if (minSize && minSize >= 2) params.min_cluster_size = minSize;
  const minSamples = $('#cluster-min-samples').value;
  if (minSamples !== '') params.min_samples = parseInt(minSamples);
  params.use_umap = $('#cluster-use-umap').checked;
  if (params.use_umap) {
    params.umap_n_components = parseInt($('#cluster-umap-components').value) || 2;
    params.umap_n_neighbors = parseInt($('#cluster-umap-neighbors').value) || 15;
    params.umap_min_dist = parseFloat($('#cluster-umap-min-dist').value) || 0.1;
  }
  return params;
}

$('#queue-cluster-btn').addEventListener('click', async () => {
  const checkedBoxes = [...$('#cluster-embed-list').querySelectorAll('input:checked')];
  const checked = checkedBoxes.map(cb => cb.value);
  if (checked.length === 0) { showMsg('cluster-msg', 'Select at least one embedding set', 'error'); return; }

  // Client-side dimension validation
  const dims = new Set(checkedBoxes.map(cb => cb.dataset.dim));
  if (dims.size > 1) {
    showMsg('cluster-msg', `Cannot cluster embedding sets with different dimensions: ${[...dims].join(', ')}`, 'error');
    return;
  }

  const params = buildClusterParams();
  try {
    const result = await api('/clustering/jobs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ embedding_set_ids: checked, parameters: params }),
    });
    clusterJobIds.unshift(result.id);
    clusterJobsHavePending = true;
    showMsg('cluster-msg', `Clustering job queued: ${shortId(result.id)}`);
    loadClusterJobs();
  } catch (e) {
    showMsg('cluster-msg', `Failed: ${e.message}`, 'error');
  }
});

// ---- Polling for running jobs ----
let clusterJobsHavePending = false;
setInterval(() => {
  const activeTab = document.querySelector('.tab-btn.active')?.dataset.tab;
  if (activeTab === 'processing') { loadProcJobs(); loadEmbeddingSets(); }
  if (activeTab === 'clustering' && clusterJobsHavePending) loadClusterJobs();
}, 3000);

// ==================== ADMIN ====================
async function loadAdminModels() {
  try {
    const models = await api('/admin/models');
    const tbody = $('#admin-models-body');
    if (models.length === 0) {
      tbody.innerHTML = '';
      $('#admin-models-empty').classList.remove('hidden');
      return;
    }
    $('#admin-models-empty').classList.add('hidden');
    tbody.innerHTML = models.map(m => `
      <tr>
        <td>${m.name}</td>
        <td>${m.display_name}</td>
        <td style="font-size:0.8rem">${m.path}</td>
        <td>${m.vector_dim}</td>
        <td>${m.is_default ? '<strong>Yes</strong>' : 'No'}</td>
        <td>
          ${!m.is_default ? `<button class="btn btn-sm btn-primary set-default-model" data-id="${m.id}">Set Default</button>` : ''}
          <button class="btn btn-sm btn-danger delete-model" data-id="${m.id}" style="margin-left:0.25rem">Delete</button>
        </td>
      </tr>`).join('');

    tbody.querySelectorAll('.set-default-model').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        try {
          await api(`/admin/models/${btn.dataset.id}/set-default`, { method: 'POST' });
          loadAdminModels();
        } catch (err) { showMsg('admin-models-msg', `Failed: ${err.message}`, 'error'); }
      });
    });
    tbody.querySelectorAll('.delete-model').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (!confirm('Delete this model from the registry?')) return;
        try {
          await api(`/admin/models/${btn.dataset.id}`, { method: 'DELETE' });
          showMsg('admin-models-msg', 'Model deleted');
          loadAdminModels();
        } catch (err) { showMsg('admin-models-msg', `Failed: ${err.message}`, 'error'); }
      });
    });
  } catch (e) { console.error(e); }
}

$('#scan-models-btn').addEventListener('click', async () => {
  try {
    const files = await api('/admin/models/scan');
    const unregistered = files.filter(f => !f.registered);
    const container = $('#scan-results');
    const list = $('#scan-results-list');
    if (unregistered.length === 0) {
      container.classList.remove('hidden');
      list.innerHTML = '<p class="empty">All .tflite files are already registered.</p>';
      return;
    }
    container.classList.remove('hidden');
    list.innerHTML = unregistered.map((f, i) => `
      <div class="card" style="padding:0.75rem;margin-bottom:0.5rem">
        <strong>${f.filename}</strong> <span style="font-size:0.8rem;color:#888">(${(f.size_bytes / 1024 / 1024).toFixed(1)} MB)</span>
        <div class="form-row" style="margin-top:0.5rem">
          <div class="form-group">
            <label>Name (identifier)</label>
            <input type="text" id="scan-name-${i}" value="${f.filename.replace('.tflite', '').replace(/[^a-zA-Z0-9_-]/g, '_')}" style="width:100%">
          </div>
          <div class="form-group">
            <label>Display Name</label>
            <input type="text" id="scan-display-${i}" value="${f.filename.replace('.tflite', '').replace(/[_-]/g, ' ')}" style="width:100%">
          </div>
          <div class="form-group">
            <label>Vector Dim</label>
            <input type="number" id="scan-dim-${i}" value="1280" min="1" style="width:100%">
          </div>
          <div class="form-group" style="display:flex;align-items:flex-end">
            <button class="btn btn-primary btn-sm register-scanned" data-index="${i}" data-path="${f.path}">Register</button>
          </div>
        </div>
      </div>`).join('');

    list.querySelectorAll('.register-scanned').forEach(btn => {
      btn.addEventListener('click', async () => {
        const idx = btn.dataset.index;
        const body = {
          name: $(`#scan-name-${idx}`).value,
          display_name: $(`#scan-display-${idx}`).value,
          path: btn.dataset.path,
          vector_dim: parseInt($(`#scan-dim-${idx}`).value),
        };
        try {
          await api('/admin/models', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });
          showMsg('admin-models-msg', `Registered: ${body.name}`);
          loadAdminModels();
          btn.closest('.card').remove();
        } catch (e) { showMsg('admin-models-msg', `Failed: ${e.message}`, 'error'); }
      });
    });
  } catch (e) { showMsg('admin-models-msg', `Scan failed: ${e.message}`, 'error'); }
});

async function loadAdminTables() {
  try {
    const tables = await api('/admin/tables');
    const tbody = $('#admin-table-body');
    if (tables.length === 0) {
      tbody.innerHTML = '';
      $('#admin-empty').classList.remove('hidden');
      return;
    }
    $('#admin-empty').classList.add('hidden');
    tbody.innerHTML = tables.map(t => `
      <tr>
        <td>${t.table}</td>
        <td>${t.count}</td>
      </tr>`).join('');
  } catch (e) { console.error(e); }
}

$('#delete-all-btn').addEventListener('click', async () => {
  if (!confirm('This will permanently delete ALL records from the database. Are you sure?')) return;
  try {
    await api('/admin/tables', { method: 'DELETE' });
    showMsg('admin-msg', 'All records deleted');
    loadAdminTables();
  } catch (e) {
    showMsg('admin-msg', `Failed: ${e.message}`, 'error');
  }
});

// ---- Initial load ----
loadAudioList();
</script>
</body>
</html>
